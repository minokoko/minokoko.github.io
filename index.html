<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="OneStack">
<meta property="og:url" content="http://jessyon.com/index.html">
<meta property="og:site_name" content="OneStack">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OneStack">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://jessyon.com/"/>

  <title> OneStack </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">OneStack</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">The Blog Powered By jessyon</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/24/服务器搭建-五-solr集群/" itemprop="url">
                  服务器搭建(五)solr集群
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-24T11:35:52+08:00" content="2016-09-24">
              2016-09-24
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/24/服务器搭建-五-solr集群/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/24/服务器搭建-五-solr集群/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="搜索系统搭建"><a href="#搜索系统搭建" class="headerlink" title="搜索系统搭建"></a>搜索系统搭建</h1><pre><code>搜索功能需要发布服务共pc端、移动端使用。根据关键词搜索，得到json格式的搜索结果。
创建一个搜索系统，发布搜索服务。
</code></pre><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/solr_infrastructure.jpg" alt=""></p>
<h2 id="Solr服务的搭建"><a href="#Solr服务的搭建" class="headerlink" title="Solr服务的搭建"></a>Solr服务的搭建</h2><pre><code>第一步：安装jdk、安装tomcat,复制一份tomcat到/usr/local/solr/目录下
cp -r apache-tomcat-7.0.47 /usr/local/solr
mv apache-tomcat-7.0.47 tomcat

第二步：解压solr压缩包。
tar -zxf solr-4.10.3.tgz.tgz
mv solr-4.10.3 /usr/local

第三步：把dist/solr-4.10.3.war部署到tomcat

第四步：解压缩war包。启动tomcat解压。

第五步：需要把/usr/local/solr-4.10.3/example/lib/ext目录下的所有的jar包添加到solr工程中。

第六步：创建solrhome。先在/usr/local下创建一个solr目录,
cd /usr/local -&gt;  mkdir solr
然后把/usr/local/solr-4.10.3/example/solr文件夹复制一份作为solrhome。
cp -r /usr/local/solr-4.10.3/example/solr /usr/local/solr/home

第七步：告诉solr服务solrhome的位置。需要修改web.xml
修改/usr/local/solr/tomcat/webapps/solr/WEB-INF/web.xml中的:
&lt;env-entry&gt;
   &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;
   &lt;env-entry-value&gt;/usr/local/solr/solrhome&lt;/env-entry-value&gt;
   &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;
&lt;/env-entry&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/20/solr全文搜索服务/" itemprop="url">
                  solr全文搜索服务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-20T10:34:11+08:00" content="2016-09-20">
              2016-09-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/20/solr全文搜索服务/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/20/solr全文搜索服务/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="站内搜索技术选型"><a href="#站内搜索技术选型" class="headerlink" title="站内搜索技术选型"></a>站内搜索技术选型</h1><pre><code>在一些大型门户网站、电子商务网站等都需要站内搜索功能，
使用传统的数据库查询方式实现搜索无法满足一些高级的搜索需求，
比如：搜索速度要快、搜索结果按相关度排序、搜索内容格式不固定等，
这里就需要使用全文检索技术实现搜索功能。
</code></pre><h2 id="单独使用Lucene实现"><a href="#单独使用Lucene实现" class="headerlink" title="单独使用Lucene实现"></a>单独使用Lucene实现</h2><pre><code>单独使用Lucene实现站内搜索需要开发的工作量较大，
主要表现在：索引维护、索引性能优化、搜索性能优化等，因此不建议采用。
</code></pre><h2 id="使用Google或Baidu接口"><a href="#使用Google或Baidu接口" class="headerlink" title="使用Google或Baidu接口"></a>使用Google或Baidu接口</h2><pre><code>通过第三方搜索引擎提供的接口实现站内搜索，这样和第三方引擎系统依赖紧密，不方便扩展，不建议采用。
</code></pre><h2 id="使用Solr实现"><a href="#使用Solr实现" class="headerlink" title="使用Solr实现"></a>使用Solr实现</h2><pre><code>基于Solr实现站内搜索扩展性较好并且可以减少程序员的工作量，
因为Solr提供了较为完备的搜索引擎解决方案，因此在门户、论坛等系统中常用此方案。
</code></pre><h1 id="Solr介绍"><a href="#Solr介绍" class="headerlink" title="Solr介绍"></a>Solr介绍</h1><h2 id="什么是Solr"><a href="#什么是Solr" class="headerlink" title="什么是Solr"></a>什么是Solr</h2><pre><code>Solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。
Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。 

Solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中，Solr 索引的实现方法很简单，
用POST方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引。
Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，
组织页面布局。Solr不提供构建UI的功能，Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。
</code></pre><h2 id="Solr与Lucene的区别"><a href="#Solr与Lucene的区别" class="headerlink" title="Solr与Lucene的区别"></a>Solr与Lucene的区别</h2><pre><code>Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索引擎，
Lucene提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，
以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索引擎。

 Solr的目标是打造一款企业级的搜索引擎系统，它是一个搜索引擎服务，可以独立运行，
通过Solr可以非常快速的构建企业的搜索引擎，通过Solr也可以高效的完成站内搜索功能。
</code></pre><h1 id="Solr安装配置"><a href="#Solr安装配置" class="headerlink" title="Solr安装配置"></a>Solr安装配置</h1><p><a href="http://lucene.apache.org/solr/" target="_blank" rel="external">http://lucene.apache.org/solr/</a></p>
<p>下载lucene-4.10.3.zip 或 lucene-4.10.3.tgz 并解压:</p>
<pre><code>bin：solr的运行脚本
contrib：solr的一些贡献软件/插件，用于增强solr的功能。
dist：该目录包含build过程中产生的war和jar文件，以及相关的依赖文件。
docs：solr的API文档
example：solr工程的例子目录：
    example/solr：
    该目录是一个包含了默认配置信息的Solr的Core目录。
    example/multicore：
    该目录包含了在Solr的multicore中设置的多个Core目录。 
    example/webapps：
    该目录中包括一个solr.war，该war可作为solr的运行实例工程。
licenses：solr相关的一些许可信息
</code></pre><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><pre><code>solr 需要运行在一个Servlet容器中，Solr4.10.3要求jdk使用1.7以上，
Solr默认提供Jetty（java写的Servlet容器）
</code></pre><p>环境如下：</p>
<pre><code>Solr：Solr4.10.3
Jdk：jdk1.7.0_72
Tomcat：apache-tomcat-7.0.53
</code></pre><h2 id="Solr与Tomcat整合配置"><a href="#Solr与Tomcat整合配置" class="headerlink" title="Solr与Tomcat整合配置"></a>Solr与Tomcat整合配置</h2><h3 id="Solr-Home与SolrCore"><a href="#Solr-Home与SolrCore" class="headerlink" title="Solr Home与SolrCore"></a>Solr Home与SolrCore</h3><pre><code>创建一个Solr home目录，SolrHome是Solr运行的主目录，目录中包括了运行Solr实例所有的配置文件和数据文件，
Solr实例就是SolrCore，一个SolrHome可以包括多个SolrCore（Solr实例），每个SolrCore提供单独的搜索和索引服务。
</code></pre><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>example\solr是一个solr home目录结构，如下：</p>
<p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/solr_example.jpg" alt=""></p>
<p>上图中“collection1”是一个SolrCore（Solr实例）目录 ，目录内容如下所示：</p>
<p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/solr_collection1.jpg" alt=""></p>
<p>说明：</p>
<pre><code>collection1：叫做一个Solr运行实例SolrCore，SolrCore名称不固定，
一个solr运行实例对外单独提供索引和搜索接口。

solrHome中可以创建多个solr运行实例SolrCore。

一个solr的运行实例对应一个索引目录。

conf是SolrCore的配置文件目录 。
</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code>创建目录 F:\develop\solr 

将example\solr目录 拷贝至 F:\develop\solr目录下并改名为solrhome
</code></pre><h4 id="solrconfig-xml"><a href="#solrconfig-xml" class="headerlink" title="solrconfig.xml"></a>solrconfig.xml</h4><pre><code>solrconfig.xml，在SolrCore的conf目录下，它是SolrCore运行的配置文件。
</code></pre><h5 id="加载jar包"><a href="#加载jar包" class="headerlink" title="加载jar包"></a>加载jar包</h5><pre><code>将contrib和dist两个目录拷贝到F:\develop\solr下，此时，solrhome,dist,contrib三个目录在同一层级
</code></pre><p>修改solrconfig.xml文件：</p>
<pre><code>&lt;lib dir=&quot;${solr.install.dir:../..}/contrib/extraction/lib&quot; regex=&quot;.*\.jar&quot; /&gt;
&lt;lib dir=&quot;${solr.install.dir:../..}/dist/&quot; regex=&quot;solr-cell-\d.*\.jar&quot; /&gt;

&lt;lib dir=&quot;${solr.install.dir:../..}/contrib/clustering/lib/&quot; regex=&quot;.*\.jar&quot; /&gt;
&lt;lib dir=&quot;${solr.install.dir:../..}/dist/&quot; regex=&quot;solr-clustering-\d.*\.jar&quot; /&gt;

&lt;lib dir=&quot;${solr.install.dir:../..}/contrib/langid/lib/&quot; regex=&quot;.*\.jar&quot; /&gt;
&lt;lib dir=&quot;${solr.install.dir:../..}/dist/&quot; regex=&quot;solr-langid-\d.*\.jar&quot; /&gt;

&lt;lib dir=&quot;${solr.install.dir:../..}/contrib/velocity/lib&quot; regex=&quot;.*\.jar&quot; /&gt;
&lt;lib dir=&quot;${solr.install.dir:../..}/dist/&quot; regex=&quot;solr-velocity-\d.*\.jar&quot; /&gt;
</code></pre><h5 id="dataDir"><a href="#dataDir" class="headerlink" title="dataDir"></a>dataDir</h5><pre><code>置SolrCore的数据目录，数据目录下包括了index索引目录 和tlog日志文件目录，
数据目录默认在solrCore下的data目录 ，也可以更改目录地址 ，如下：

  &lt;dataDir&gt;${solr.data.dir:F:/develop/solr/collection1/data}&lt;/dataDir&gt;
</code></pre><h5 id="requestHandler"><a href="#requestHandler" class="headerlink" title="requestHandler"></a>requestHandler</h5><pre><code>requestHandler请求处理器，定义了索引和搜索的访问方式。

通过/update维护索引，可以完成索引的添加、修改、删除操作。
通过/select搜索索引。
设置搜索参数完成搜索，搜索参数也可以设置一些默认值，如下：

&lt;requestHandler name=&quot;/select&quot; class=&quot;solr.SearchHandler&quot;&gt;
&lt;!-- 设置默认的参数值，可以在请求地址中修改这些参数--&gt;
&lt;lst name=&quot;defaults&quot;&gt;
    &lt;str name=&quot;echoParams&quot;&gt;explicit&lt;/str&gt;
    &lt;int name=&quot;rows&quot;&gt;10&lt;/int&gt;&lt;!--显示数量--&gt;
    &lt;str name=&quot;wt&quot;&gt;json&lt;/str&gt;&lt;!--显示格式--&gt;
    &lt;str name=&quot;df&quot;&gt;text&lt;/str&gt;&lt;!--默认搜索字段--&gt;
&lt;/lst&gt;
&lt;/requestHandler&gt;
</code></pre><h2 id="Solr工程部署"><a href="#Solr工程部署" class="headerlink" title="Solr工程部署"></a>Solr工程部署</h2><pre><code>1.    将dist\solr-4.10.3.war拷贝到Tomcat的webapp目录下改名为solr.war

2.    启动tomcat后，solr.war自动解压，将原来的solr.war删除。

3.    拷贝example\lib\ext 目录下所有jar包到Tomcat的webapp\solr\WEB-INF\lib目录下
4.    修改Tomcat目录 下webapp\solr\WEB-INF\web.xml文件，如下所示：
    设置Solr home

    &lt;env-entry&gt;
    &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;
    &lt;env-entry-value&gt;f:/develop/solr/solrhome&lt;/env-entry-value&gt;
    &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;
    &lt;/env-entry&gt;

5.    拷贝log4j.properties文件

    在 Tomcat下webapps\solr\WEB-INF目录中创建文件 classes文件夹，
    复制Solr目录下example\resources\log4j.properties至Tomcat下webapps\solr\WEB-INF\classes目录 
</code></pre><h2 id="启动Tomcat"><a href="#启动Tomcat" class="headerlink" title="启动Tomcat"></a>启动Tomcat</h2><p>启动tomcat服务器,在浏览器输入: localhost/solr</p>
<p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/solr_index.JPG" alt=""></p>
<h3 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h3><pre><code>仪表盘，显示了该Solr实例开始启动运行的时间、版本、系统资源、jvm等信息。
</code></pre><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><pre><code>Solr运行日志信息
</code></pre><h3 id="Cloud"><a href="#Cloud" class="headerlink" title="Cloud"></a>Cloud</h3><pre><code>Cloud即SolrCloud，即Solr云（集群），当使用Solr Cloud模式运行时会显示此菜单
</code></pre><h3 id="Core-Admin"><a href="#Core-Admin" class="headerlink" title="Core Admin"></a>Core Admin</h3><pre><code>Solr Core的管理界面。Solr Core 是Solr的一个独立运行实例单位，它可以对外提供索引和搜索服务，
一个Solr工程可以运行多个SolrCore（Solr实例），一个Core对应一个索引目录。
</code></pre><h3 id="java-properties"><a href="#java-properties" class="headerlink" title="java properties"></a>java properties</h3><pre><code>Solr在JVM 运行环境中的属性信息，包括类路径、文件编码、jvm内存设置等信息。
</code></pre><h3 id="Tread-Dump"><a href="#Tread-Dump" class="headerlink" title="Tread Dump"></a>Tread Dump</h3><pre><code>显示Solr Server中当前活跃线程信息，同时也可以跟踪线程运行栈信息。
</code></pre><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><pre><code>通过此界面可以测试索引分析器和搜索分析器的执行情况。
</code></pre><h3 id="dataimport"><a href="#dataimport" class="headerlink" title="dataimport"></a>dataimport</h3><pre><code>可以定义数据导入处理器，从关系数据库将数据导入 到Solr索引库中。
</code></pre><h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><pre><code>通过此菜单可以创建索引、更新索引、删除索引等操作
/update表示更新索引，solr默认根据id（唯一约束）域来更新Document的内容，
如果根据id值搜索不到id域则会执行添加操作，如果找到则更新。
</code></pre><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><pre><code>通过/select执行搜索索引，必须指定“q”查询条件方可搜索。
</code></pre><h2 id="多core配置"><a href="#多core配置" class="headerlink" title="多core配置"></a>多core配置</h2><pre><code>复制原来的core目录为collection2
修改collection2下的core.properties:
name=collection2
</code></pre><h1 id="Solr索引"><a href="#Solr索引" class="headerlink" title="Solr索引"></a>Solr索引</h1><h2 id="scheam-xml"><a href="#scheam-xml" class="headerlink" title="scheam.xml"></a>scheam.xml</h2><pre><code>schema.xml，在SolrCore的conf目录下，它是Solr数据表配置文件，它定义了加入索引的数据的数据类型的。
主要包括FieldTypes、Fields和其他的一些缺省设置。
</code></pre><h3 id="FieldType域类型定义"><a href="#FieldType域类型定义" class="headerlink" title="FieldType域类型定义"></a>FieldType域类型定义</h3><p>下边“text_general”是Solr默认提供的FieldType，通过它说明FieldType定义的内容：</p>
<pre><code> &lt;fieldType name=&quot;text_general&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt;
  &lt;analyzer type=&quot;index&quot;&gt;
    &lt;tokenizer class=&quot;solr.StandardTokenizerFactory&quot;/&gt;
    &lt;filter class=&quot;solr.StopFilterFactory&quot; ignoreCase=&quot;true&quot; words=&quot;stopwords.txt&quot; /&gt;
    &lt;!-- in this example, we will only use synonyms at query time
    &lt;filter class=&quot;solr.SynonymFilterFactory&quot; synonyms=&quot;index_synonyms.txt&quot; ignoreCase=&quot;true&quot; expand=&quot;false&quot;/&gt;
    --&gt;
    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
  &lt;/analyzer&gt;
  &lt;analyzer type=&quot;query&quot;&gt;
    &lt;tokenizer class=&quot;solr.StandardTokenizerFactory&quot;/&gt;
    &lt;filter class=&quot;solr.StopFilterFactory&quot; ignoreCase=&quot;true&quot; words=&quot;stopwords.txt&quot; /&gt;
    &lt;filter class=&quot;solr.SynonymFilterFactory&quot; synonyms=&quot;synonyms.txt&quot; ignoreCase=&quot;true&quot; expand=&quot;true&quot;/&gt;
    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
  &lt;/analyzer&gt;
&lt;/fieldType&gt;
</code></pre><p>FieldType子结点包括：name,class,positionIncrementGap等一些参数：</p>
<pre><code>name：是这个FieldType的名称

class：是Solr提供的包solr.TextField，solr.TextField 允许用户通过分析器来定制索引和查询，
分析器包括一个分词器（tokenizer）和多个过滤器（filter）

positionIncrementGap：可选属性，定义在同一个文档中此类型数据的空白间隔，
避免短语匹配错误，此值相当于Lucene的短语查询设置slop值，根据经验设置为100。

在FieldType定义的时候最重要的就是,
定义这个类型的数据在建立索引和进行查询的时候要使用的分析器analyzer,包括分词和过滤

索引分析器中：使用solr.StandardTokenizerFactory标准分词器，
solr.StopFilterFactory停用词过滤器，
solr.LowerCaseFilterFactory小写过滤器。

搜索分析器中：使用solr.StandardTokenizerFactory标准分词器，
solr.StopFilterFactory停用词过滤器，这里还用到了solr.SynonymFilterFactory同义词过滤器。
</code></pre><h3 id="Field定义"><a href="#Field定义" class="headerlink" title="Field定义"></a>Field定义</h3><pre><code>在solr中，Field要先定义后使用。
在fields结点内定义具体的Field，filed定义包括name,
type（为之前定义过的各种FieldType）,indexed（是否被索引）,stored（是否被储存），multiValued（是否存储多个值,比如多个商品图片）等属性。
</code></pre><p>如下：</p>
<pre><code>&lt;field name=&quot;name&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;
&lt;field name=&quot;features&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt;

multiValued：该Field如果要存储多个值时设置为true，solr允许一个Field存储多个值，比如存储一个用户的好友id（多个），
商品的图片（多个，大图和小图），通过使用solr查询要看出返回给客户端是数组。
</code></pre><h3 id="uniqueKey"><a href="#uniqueKey" class="headerlink" title="uniqueKey"></a>uniqueKey</h3><pre><code>Solr中默认定义唯一主键key为id域，如下：

&lt;uniqueKey&gt;id&lt;/uniqueKey&gt;

Solr在删除、更新索引时使用id域进行判断，也可以自定义唯一主键。
</code></pre><h3 id="copyField复制域"><a href="#copyField复制域" class="headerlink" title="copyField复制域"></a>copyField复制域</h3><p>copyField复制域，可以将多个Field复制到一个Field中，以便进行统一的检索：<br>比如，输入关键字搜索title标题内容content，</p>
<pre><code>定义title、content、text的域：

&lt;field name=&quot;title&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt;
&lt;field name=&quot;subject&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;
&lt;field name=&quot;description&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;
</code></pre><p>根据关键字只搜索text域的内容就相当于搜索title和content，将title和content复制到text中，如下：</p>
<pre><code>&lt;copyField source=&quot;cat&quot; dest=&quot;text&quot;/&gt;
&lt;copyField source=&quot;name&quot; dest=&quot;text&quot;/&gt;
&lt;copyField source=&quot;manu&quot; dest=&quot;text&quot;/&gt;
&lt;copyField source=&quot;features&quot; dest=&quot;text&quot;/&gt;
&lt;copyField source=&quot;includes&quot; dest=&quot;text&quot;/&gt;
&lt;copyField source=&quot;manu&quot; dest=&quot;manu_exact&quot;/&gt;
</code></pre><h3 id="dynamicField（动态字段）"><a href="#dynamicField（动态字段）" class="headerlink" title="dynamicField（动态字段）"></a>dynamicField（动态字段）</h3><pre><code>动态字段就是不用指定具体的名称，只要定义字段名称的规则，
例如定义一个 dynamicField，name 为*_i，定义它的type为text，
那么在使用这个字段的时候，任何以_i结尾的字段都被认为是符合这个定义的，
例如：name_i，gender_i，school_i等。

自定义Field名为：product_title_t，“product_title_t”和scheam.xml中的dynamicField规则匹配成功，如下：

&lt;dynamicField name=&quot;*_i&quot;  type=&quot;int&quot;  indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;

“product_title_t”是以“_t”结尾。
</code></pre><h2 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h2><h3 id="安装中文分词器"><a href="#安装中文分词器" class="headerlink" title="安装中文分词器"></a>安装中文分词器</h3><h4 id="IKAnalyzer部署"><a href="#IKAnalyzer部署" class="headerlink" title="IKAnalyzer部署"></a>IKAnalyzer部署</h4><pre><code>拷贝IKAnalyzer的文件到Tomcat下Solr目录 中

将IKAnalyzer2012FF_u1.jar拷贝到 Tomcat的webapps/solr/WEB-INF/lib 下。
在Tomcat的webapps/solr/WEB-INF/下创建classes目录
将IKAnalyzer.cfg.xml、ext_stopword.dic  mydict.dic  copy到 Tomcat的
webapps/solr/WEB-INF/classes

注意：ext_stopword.dic 和mydict.dic必须保存成无BOM的utf-8类型。
</code></pre><h4 id="修改schema-xml文件"><a href="#修改schema-xml文件" class="headerlink" title="修改schema.xml文件"></a>修改schema.xml文件</h4><pre><code>1.    FieldType

首先需要在types结点内定义一个FieldType子结点，包括name,class,等参数，
name就是这个FieldType的名称，
class指向org.apache.solr.analysis包里面对应的class名称，用来定义这个类型的行为。
在FieldType定义的时候最重要的就是定义这个类型的数据在建立索引和进行查询的时候要使用的分析器analyzer,包括分词和过滤
</code></pre><p>修改Solr的schema.xml文件，添加FieldType：</p>
<pre><code>&lt;!-- IKAnalyzer--&gt;
     &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;
        &lt;analyzer type=&quot;index&quot; isMaxWordLength=&quot;false&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;
        &lt;analyzer type=&quot;query&quot; isMaxWordLength=&quot;true&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;
     &lt;/fieldType&gt;
</code></pre><p>其中查询采用IK自己的最大分词法,索引则采用它的细粒度分词法.所以各自配置了isMaxWordLength属性.</p>
<pre><code>2.    Field：

FieldType定义好后就可以在fields结点内定义具体的field，filed定义包括:
name,type（即FieldType）,indexed（是否被索引）,stored（是否被储存），multiValued（是否有多个值）等

&lt;!--IKAnalyzer Field--&gt;
   &lt;field name=&quot;title_ik&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;
   &lt;field name=&quot;content_ik&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;
</code></pre><h2 id="设置业务系统Field"><a href="#设置业务系统Field" class="headerlink" title="设置业务系统Field"></a>设置业务系统Field</h2><p>如果不使用Solr提供的Field可以针对具体的业务需要自定义一套Field，如下是商品信息Field：</p>
<pre><code> &lt;!--product--&gt;
&lt;field name=&quot;product_name&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;
&lt;field name=&quot;product_price&quot;  type=&quot;float&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;
&lt;field name=&quot;product_description&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; /&gt;
&lt;field name=&quot;product_picture&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;
&lt;field name=&quot;product_catalog_name&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;

&lt;field name=&quot;product_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;
&lt;copyField source=&quot;product_name&quot; dest=&quot;product_keywords&quot;/&gt;
&lt;copyField source=&quot;product_description&quot; dest=&quot;product_keywords&quot;/&gt;
</code></pre><h2 id="dataimport-handler"><a href="#dataimport-handler" class="headerlink" title="dataimport-handler"></a>dataimport-handler</h2><p>安装dataimport-Handler从关系数据库将数据导入到索引库。</p>
<pre><code>第一步：向SolrCore中加入jar包
在SolrCore目录中创建lib目录，将dataimportHandler和mysql数据库驱动的jar拷贝至lib下：
dataimportHandler在solr安装目录的dist下。
复制到D:\apache-solr-home\contrib\dataimporthandler\lib
mysql驱动复制到D:\apache-solr-home\contrib\db\lib

第二步 : 修改solrconfig.xml文件，添加requestHandler

     &lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;
     &lt;lst name=&quot;defaults&quot;&gt;
       &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt;
     &lt;/lst&gt;
      &lt;/requestHandler&gt;

第三步：编辑data-config.xml文件，存放在SolrCore的conf目录 

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  
    &lt;dataConfig&gt;   
    &lt;dataSource type=&quot;JdbcDataSource&quot;   
              driver=&quot;com.mysql.jdbc.Driver&quot;   
              url=&quot;jdbc:mysql://localhost:3306/lucene&quot;   
              user=&quot;w6233834&quot;   
              password=&quot;6233834&quot;/&gt;   
        &lt;document&gt;   
            &lt;entity name=&quot;product&quot; query=&quot;SELECT id,name,catalog_name,price,description,pic FROM products &quot;&gt;
                 &lt;field column=&quot;id&quot; name=&quot;id&quot;/&gt; 
                 &lt;field column=&quot;name&quot; name=&quot;product_name&quot;/&gt; 
                 &lt;field column=&quot;catalog_name&quot; name=&quot;product_catalog_name&quot;/&gt; 
                 &lt;field column=&quot;price&quot; name=&quot;product_price&quot;/&gt; 
                 &lt;field column=&quot;description&quot; name=&quot;product_description&quot;/&gt; 
                 &lt;field column=&quot;pic&quot; name=&quot;product_picture&quot;/&gt; 
            &lt;/entity&gt;   
        &lt;/document&gt;   
    &lt;/dataConfig&gt;

    &lt;field column=&quot;id&quot; name=&quot;id&quot;/&gt;必须有一个id域，这里使用Solr默认的id域，域值是从关系数据库查询的id列值。
    下边以“product_”开头的Field都是在schema.xml中自定义的商品信息Field。

第四步：重启Tomcat，进入管理界面 -&gt; SolrCore -&gt; dataimport下执行导入
</code></pre><h2 id="SolrJ完成索引维护"><a href="#SolrJ完成索引维护" class="headerlink" title="SolrJ完成索引维护"></a>SolrJ完成索引维护</h2><h3 id="什么是SolrJ"><a href="#什么是SolrJ" class="headerlink" title="什么是SolrJ"></a>什么是SolrJ</h3><pre><code>solrj是访问Solr服务的java客户端，提供索引和搜索的请求方法，
SolrJ通常在嵌入在业务系统中，通过SolrJ的API接口操作Solr服务。
</code></pre><p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/solrJ.jpg" alt=""></p>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>使用SolrJ创建索引，通过调用SolrJ提供的API请求Solr服务，Document通过SolrInputDocument进行构建。</p>
<pre><code>@Test
public void createIndex() throws SolrServerException, IOException{

    //创建HttpSolrServer
    //参数：表示solr服务的访问基础url
    HttpSolrServer server = new HttpSolrServer(&quot;http://localhost/solr&quot;);
    //通过server添加SolrInputDocument
    SolrInputDocument doc = new SolrInputDocument();
    doc.addField(&quot;id&quot;, &quot;X001&quot;);
    doc.addField(&quot;content_ik&quot;, &quot;我爱中国&quot;);

    server.add(doc);
    //提交操作
    server.commit();
}
</code></pre><p>说明：根据id（唯一约束）域来更新Document的内容，如果根据id值搜索不到id域则会执行添加操作，如果找到则更新。</p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><pre><code>@Test
public void deleteIndex() throws SolrServerException, IOException{
    //创建HttpSolrServer
    //参数：表示solr服务的访问基础url
    HttpSolrServer server = new HttpSolrServer(&quot;http://localhost/solr&quot;);

    server.deleteById(&quot;CX001&quot;);

    server.commit();
}    


@Test
public void deleteIndexByQuery() throws SolrServerException, IOException{
    //创建HttpSolrServer
    //参数：表示solr服务的访问基础url
    HttpSolrServer server = new HttpSolrServer(&quot;http://localhost/solr&quot;);

    //根据条件删除
    server.deleteByQuery(&quot;id:cx001&quot;);

    //批量删除
    server.deleteByQuery(&quot;content_ik:我爱中国&quot;);

    server.commit();
}
</code></pre><h4 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h4><pre><code>@Test
public void searchIndex02() throws SolrServerException{
    //创建HttpSolrServer
    //参数：表示solr服务的访问基础url
    HttpSolrServer server = new HttpSolrServer(&quot;http://localhost/solr&quot;);

    //创建查询对象
    SolrQuery query = new SolrQuery();

    //设置查询条件
    query.setQuery(&quot;小黄人&quot;);

    //设置过滤条件
    query.addFilterQuery(&quot;product_catalog_name:幽默杂货&quot;);
    query.addFilterQuery(&quot;product_price:[5 TO 20]&quot;);

    //设置排序
    query.setSort(&quot;product_price&quot;, ORDER.desc);

    //设置分页信息
    query.setStart(0);
    query.setRows(10);

    //设置需要显示的域列表
    query.setFields(&quot;id,product_name,product_price,product_catalog_name,product_picture&quot;);

    //设置默认搜索域
    query.set(&quot;df&quot;, &quot;product_keywords&quot;);

    //设置高亮
    query.setHighlight(true);
    query.addHighlightField(&quot;product_name&quot;);
    query.setHighlightSimplePre(&quot;&lt;font style=\&quot;color:red\&quot;&gt;&quot;);
    query.setHighlightSimplePost(&quot;&lt;/font&gt;&quot;);

    QueryResponse response = server.query(query);

    //获取查询结果
    SolrDocumentList results = response.getResults();

    //匹配出的所有商品记录条数
    long numFound = results.getNumFound();

    System.out.println(&quot;匹配出的所有商品记录条数: &quot;+numFound);

    //获取高亮信息
    Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting();

    for (SolrDocument solrDocument : results) {

        System.out.println(&quot;商品id: &quot;+solrDocument.get(&quot;id&quot;));
        System.out.println(&quot;商品name: &quot;+solrDocument.get(&quot;product_name&quot;));
        System.out.println(&quot;商品price: &quot;+solrDocument.get(&quot;product_price&quot;));
        System.out.println(&quot;商品分类名称: &quot;+solrDocument.get(&quot;product_catalog_name&quot;));
        System.out.println(&quot;商品图片: &quot;+solrDocument.get(&quot;product_picture&quot;));

        List&lt;String&gt; list = highlighting.get(solrDocument.get(&quot;id&quot;)).get(&quot;product_name&quot;);

        if(list!= null) System.out.println(&quot;显示高亮信息: &quot;+list.get(0));

        System.out.println(&quot;====================================================&quot;);

    }

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/lucene域、索引维护、搜索、中文分词/" itemprop="url">
                  lucene域、索引维护、搜索、中文分词
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T20:50:29+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/19/lucene域、索引维护、搜索、中文分词/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/19/lucene域、索引维护、搜索、中文分词/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Field域"><a href="#Field域" class="headerlink" title="Field域"></a>Field域</h1><h2 id="Field属性"><a href="#Field属性" class="headerlink" title="Field属性"></a>Field属性</h2><pre><code>Field是文档中的域，包括Field名和Field值两部分，一个文档可以包括多个Field，
Document只是Field的一个承载体，Field值即为要索引的内容，也是要搜索的内容。
</code></pre><p>是否分词(tokenized)</p>
<pre><code>是：作分词处理，即将Field值进行分词，分词的目的是为了索引。
比如：商品名称、商品简介等，这些内容用户要输入关键字搜索，由于搜索的内容格式大、内容多需要分词后将语汇单元索引。

否：不作分词处理
比如：商品id、订单号、身份证号等 
</code></pre><p>是否索引(indexed)</p>
<pre><code>是：进行索引。将Field分词后的词或整个Field值进行索引，索引的目的是为了搜索。
比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。

否：不索引。该域的内容无法搜索到
比如：商品id、文件路径、图片路径等，不用作为查询条件的不用索引。
</code></pre><p>是否存储(stored)</p>
<pre><code>是：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。
比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。

否：不存储Field值，不存储的Field无法通过Document获取
比如：商品简介，内容较大不用存储。如果要向用户展示商品简介可以从系统的关系数据库中获取商品简介。
</code></pre><h2 id="Field常用类型"><a href="#Field常用类型" class="headerlink" title="Field常用类型"></a>Field常用类型</h2><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_field.jpg" alt=""></p>
<h2 id="Field代码说明"><a href="#Field代码说明" class="headerlink" title="Field代码说明"></a>Field代码说明</h2><pre><code>图书id：
是否分词：不用分词，因为不会根据商品id来搜索商品 
是否索引：不索引，因为不需要根据图书ID进行搜索
是否存储：要存储，因为查询结果页面需要使用id这个值。

图书名称：
是否分词：要分词，因为要将图书的名称内容分词索引，根据关键搜索图书名称抽取的词。
是否索引：要索引。
是否存储：要存储。

图书价格：
是否分词：要分词，lucene对数字型的值只要有搜索需求的都要分词和索引，
因为lucene对数字型的内容要特殊分词处理，本例子可能要根据价格范围搜索，需要分词和索引。

是否索引：要索引

是否存储：要存储

图书图片地址：
是否分词：不分词
是否索引：不索引
是否存储：要存储

图书描述：
是否分词：要分词
是否索引：要索引
是否存储：因为图书描述内容量大，不在查询结果页面直接显示，不存储。

不存储是来不在lucene的索引文件中记录，节省lucene的索引文件空间，如果要在详情页面显示描述，思路：
从lucene中取出图书的id，根据图书的id查询关系数据库中book表得到描述信息。
</code></pre><h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>管理人员通过电商系统更改图书信息，这时更新的是数据库，如果使用lucene搜索图书信息需要在数据库表book信息变化时及时更新lucene索引库。</p>
<h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><pre><code>调用 indexWriter.addDocument（doc）添加索引。
参考入门程序的创建索引。
</code></pre><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><pre><code>private IndexWriter getWriter(){
        try {
            //3.进行分词
            Analyzer analyzer = new StandardAnalyzer();

            //4.创建indexWriter
            //4.1创建Directory 目录流
            IndexWriterConfig indexconfig = new IndexWriterConfig(Version.LUCENE_4_10_3, analyzer);

            //Directory 是抽象类，有两个实现类，FSDirectory(文件系统) RAMDirectory(内存)
            Directory directory = FSDirectory.open(new File(&quot;F:\\index&quot;));
            return new IndexWriter(directory,indexconfig);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

@Test
public void deleteIndex() throws Exception{

        IndexWriter writer = getWriter();

        writer.deleteDocuments(new Term(&quot;name&quot;,&quot;神&quot;));



        //6.关闭IndexWriter
        writer.close();
    }
</code></pre><h2 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h2><p>更新索引是先删除再添加，建议对更新需求采用此方法并且要保证对已存在的索引执行更新，可以先查询出来，确定更新记录存在执行更新操作。</p>
<pre><code>// 修改索引
@Test
public void updateIndex() throws Exception {
    // 1、指定索引库目录
    Directory directory = FSDirectory.open(new File(&quot;F:\\index&quot;));
    // 2、创建IndexWriterConfig
    IndexWriterConfig cfg = new IndexWriterConfig(Version.LATEST,
            new StandardAnalyzer());
    // 3、 创建IndexWriter
    IndexWriter writer = new IndexWriter(directory, cfg);
    // 4、通过IndexWriter来修改索引
    // a)、创建修改后的文档对象
    Document document = new Document();

    // 文件名称
    Field filenameField = new StringField(&quot;filename&quot;, &quot;updateIndex&quot;, Store.YES);
    document.add(filenameField);

    // 修改指定索引为新的索引
    writer.updateDocument(new Term(&quot;filename&quot;, &quot;apache&quot;), document);

    // 5、关闭IndexWriter
    writer.close();
}
</code></pre><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="创建查询的两种方法"><a href="#创建查询的两种方法" class="headerlink" title="创建查询的两种方法"></a>创建查询的两种方法</h2><pre><code>对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法。类似关系数据库Sql语法一样，Lucene也有自己的查询语法，
比如：“name:lucene”表示查询Field的name为“lucene”的文档信息。
可通过两种方法创建查询对象：
</code></pre><p>1）使用Lucene提供Query子类</p>
<pre><code>Query是一个抽象类，lucene提供了很多查询对象，比如TermQuery项精确查询，NumericRangeQuery数字范围查询等。
如下代码：
Query query = new TermQuery(new Term(&quot;name&quot;, &quot;lucene&quot;));
</code></pre><p>2）使用QueryParse解析查询表达式</p>
<pre><code>QueryParser会将用户输入的查询表达式解析成Query对象实例。
如下代码：
QueryParser queryParser = new QueryParser(&quot;name&quot;, new IKAnalyzer());
Query query = queryParser.parse(&quot;name:lucene&quot;);
</code></pre><h2 id="通过Query子类搜索"><a href="#通过Query子类搜索" class="headerlink" title="通过Query子类搜索"></a>通过Query子类搜索</h2><h3 id="TermQuery"><a href="#TermQuery" class="headerlink" title="TermQuery"></a>TermQuery</h3><p>TermQuery项查询，TermQuery不使用分析器，搜索关键词作为整体来匹配Field域中的词进行查询，比如订单号、分类ID号等。</p>
<pre><code>private void doSearch(Query query) {
    IndexReader reader = null;
    try {
        // a) 指定索引库目录
        Directory indexdirectory = FSDirectory.open(new File(
                &quot;F:\\index&quot;));
        // b) 创建IndexReader对象
        reader = DirectoryReader.open(indexdirectory);
        // c) 创建IndexSearcher对象
        IndexSearcher searcher = new IndexSearcher(reader);
        // d) 通过IndexSearcher对象执行查询索引库，返回TopDocs对象
        // 第一个参数：查询对象
        // 第二个参数：最大的n条记录
        TopDocs topDocs = searcher.search(query, 10);
        // e) 提取TopDocs对象中的文档ID，如何找出对应的文档
        ScoreDoc[] scoreDocs = topDocs.scoreDocs;
        System.out.println(&quot;总共查询出的结果总数为：&quot; + topDocs.totalHits);
        Document doc;
        for (ScoreDoc scoreDoc : scoreDocs) {
            // 文档对象ID
            int docId = scoreDoc.doc;
            doc = searcher.doc(docId);
            // f) 输出文档内容
            System.out.println(doc.get(&quot;filename&quot;));
            System.out.println(doc.get(&quot;path&quot;));
            System.out.println(doc.get(&quot;size&quot;));
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (reader != null) {
            try {
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

@Test
public void testTermQuery() throws Exception {
    // 1、 创建查询（Query对象）
    Query query = new TermQuery(new Term(&quot;filename&quot;, &quot;apache&quot;));
    // 2、 执行搜索
    doSearch(query);
}
</code></pre><h3 id="NumbericRangeQuery"><a href="#NumbericRangeQuery" class="headerlink" title="NumbericRangeQuery"></a>NumbericRangeQuery</h3><p>NumericRangeQuery，指定数字范围查询.</p>
<pre><code>@Test
public void testNumbericRangeQuery() throws Exception {
    // 创建查询
    // 第一个参数：域名
    // 第二个参数：最小值
    // 第三个参数：最大值
    // 第四个参数：是否包含最小值
    // 第五个参数：是否包含最大值
    Query query = NumericRangeQuery.newLongRange(&quot;size&quot;, 1l, 100l, true,true);
    // 2、 执行搜索
    doSearch(query);
}
</code></pre><h3 id="BooleanQuery"><a href="#BooleanQuery" class="headerlink" title="BooleanQuery"></a>BooleanQuery</h3><p>BooleanQuery，布尔查询，实现组合条件查询。</p>
<pre><code>@Test
public void booleanQuery() throws Exception {
    BooleanQuery query = new BooleanQuery();
    Query query1 = new TermQuery(new Term(&quot;id&quot;, &quot;3&quot;));
    Query query2 = NumericRangeQuery.newFloatRange(&quot;price&quot;, 10f, 200f,
            true, true);

    //MUST：查询条件必须满足，相当于AND
    //SHOULD:查询条件可选，相当于OR
    //MUST_NOT：查询条件不能满足，相当于NOT非
    query.add(query1, Occur.MUST);
    query.add(query2, Occur.SHOULD);

    System.out.println(query);

    search(query);
}
</code></pre><p>组合关系代表的意思如下: </p>
<pre><code>1、MUST和MUST表示“与”的关系，即“并集”。 
2、MUST和MUST_NOT前者包含后者不包含。 
3、MUST_NOT和MUST_NOT没意义 
4、SHOULD与MUST表示MUST，SHOULD失去意义； 
5、SHOUlD与MUST_NOT相当于MUST与MUST_NOT。 
6、SHOULD与SHOULD表示“或”的概念。
</code></pre><h2 id="通过QueryParser搜索"><a href="#通过QueryParser搜索" class="headerlink" title="通过QueryParser搜索"></a>通过QueryParser搜索</h2><pre><code>通过QueryParser也可以创建Query，QueryParser提供一个Parse方法，
此方法可以直接根据查询语法来查询。Query对象执行的查询语法可通过System.out.println(query);查询。
</code></pre><h3 id="QueryParser"><a href="#QueryParser" class="headerlink" title="QueryParser"></a>QueryParser</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>@Test
public void testQueryParser() throws Exception {
    // 创建QueryParser
    // 第一个参数：默认域名
    // 第二个参数：分词器
    QueryParser queryParser = new QueryParser(&quot;name&quot;, new IKAnalyzer());
    // 指定查询语法 ，如果不指定域，就搜索默认的域
        Query query = queryParser.parse(&quot;lucene&quot;);
        System.out.println(query);
    // 2、 执行搜索
            doSearch(query);

    }
</code></pre><h4 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h4><pre><code>1、基础的查询语法，关键词查询：
域名+“：”+搜索的关键字
例如：content:java
2、范围查询
域名+“:”+[最小值 TO 最大值]
例如：size:[1 TO 1000]
注意：QueryParser不支持对数字范围的搜索，它支持字符串范围。数字范围搜索建议使用NumericRangeQuery。

3、组合条件查询
Occur.MUST     查询条件必须满足，  相当于and     +（加号）
Occur.SHOULD   查询条件可选，     相当于or 空 （不用符号）
Occur.MUST_NOT 查询条件不能满足，  相当于not非     -（减号）

1）+条件1 +条件2：两个条件之间是并且的关系and
例如：+filename:apache +content:apache
2）+条件1 条件2：必须满足第一个条件，忽略第二个条件
例如：+filename:apache content:apache
3）条件1 条件2：两个条件满足其一即可。
例如：filename:apache content:apache
4）-条件1 条件2：必须不满足条件1，要满足条件2
例如：-filename:apache content:apache

第二种写法：
条件1 AND 条件2
条件1 OR 条件2
条件1 NOT 条件2
</code></pre><h3 id="MultiFieldQueryParser"><a href="#MultiFieldQueryParser" class="headerlink" title="MultiFieldQueryParser"></a>MultiFieldQueryParser</h3><p>通过MuliFieldQueryParse对多个域查询。</p>
<pre><code>@Test
public void testMultiFieldQueryParser() throws Exception {
    // 可以指定默认搜索的域是多个
        String[] fields = { &quot;name&quot;, &quot;description&quot; };
    // 创建一个MulitFiledQueryParser对象
        QueryParser parser = new MultiFieldQueryParser(fields, new IKAnalyzer());
    // 指定查询语法 ，如果不指定域，就搜索默认的域
        Query query = parser.parse(&quot;lucene&quot;);
    // 2、 执行搜索
        doSearch(query);
}
</code></pre><h2 id="TopDocs"><a href="#TopDocs" class="headerlink" title="TopDocs"></a>TopDocs</h2><p>Lucene搜索结果可通过TopDocs遍历，TopDocs类提供了少量的属性，如下：</p>
<pre><code>方法或属性    说明
totalHits    匹配搜索条件的总记录数
scoreDocs    顶部匹配记录
</code></pre><p>注意：</p>
<pre><code>Search方法需要指定匹配记录数量n：indexSearcher.search(query, n)
TopDocs.totalHits：是匹配索引库中所有记录的数量
TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n
</code></pre><h1 id="相关度排序"><a href="#相关度排序" class="headerlink" title="相关度排序"></a>相关度排序</h1><h2 id="什么是相关度排序"><a href="#什么是相关度排序" class="headerlink" title="什么是相关度排序"></a>什么是相关度排序</h2><pre><code>相关度排序是查询结果按照与查询关键字的相关性进行排序，越相关的越靠前。
比如搜索“Lucene”关键字，与该关键字最相关的文章应该排在前边。
</code></pre><h2 id="相关度打分"><a href="#相关度打分" class="headerlink" title="相关度打分"></a>相关度打分</h2><pre><code>Lucene对查询关键字和索引文档的相关度进行打分，得分高的就排在前边。如何打分呢？Lucene是在用户进行检索时实时根据搜索的关键字计算出来的，分两步：
1）计算出词（Term）的权重
2）根据词的权重值，计算文档相关度得分。
</code></pre><p>什么是词的权重？</p>
<pre><code>通过索引部分的学习，明确索引的最小单位是一个Term(索引词典中的一个词)，
搜索也是要从Term中搜索，再根据Term找到文档，Term对文档的重要性称为权重，
影响Term权重有两个因素：

Term Frequency (tf)：
指此Term在此文档中出现了多少次。tf 越大说明越重要。 
词(Term)在文档中出现的次数越多，说明此词(Term)对该文档越重要，
如“Lucene”这个词，在文档中出现的次数很多，说明该文档主要就是讲Lucene技术的。

Document Frequency (df)：
指有多少文档包含次Term。df 越大说明越不重要。 
比如，在一篇英语文档中，this出现的次数更多，就说明越重要吗？
不是的，有越多的文档包含此词(Term), 说明此词(Term)太普通，
不足以区分这些文档，因而重要性越低。
</code></pre><h2 id="设置boost值影响相关度排序"><a href="#设置boost值影响相关度排序" class="headerlink" title="设置boost值影响相关度排序"></a>设置boost值影响相关度排序</h2><pre><code>boost是一个加权值（默认加权值为1.0f），它可以影响权重的计算。

在索引时对某个文档中的field设置加权值高，在搜索时匹配到这个文档就可能排在前边。

在搜索时对某个域进行加权，在进行组合域查询时，匹配到加权值高的域最后计算的相关度得分就高。

设置boost是给域（field）或者Document设置的。
</code></pre><h3 id="在创建索引时设置"><a href="#在创建索引时设置" class="headerlink" title="在创建索引时设置"></a>在创建索引时设置</h3><pre><code>如果希望某些文档更重要，当此文档中包含所要查询的词则应该得分较高，
这样相关度排序可以排在前边，可以在创建索引时设定文档中某些域（Field）的boost值来实现，
如果不进行设定，则Field Boost默认为1.0f。一旦设定，除非删除此文档，否则无法改变。
</code></pre><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>@Test
public void setBoost4createIndex() throws Exception {
    // 创建分词器
    Analyzer analyzer = new StandardAnalyzer();

    IndexWriterConfig cfg = new IndexWriterConfig(Version.LUCENE_4_10_3,
            analyzer);
    Directory directory = FSDirectory.open(new File(&quot;F:\\index&quot;));
    // 创建IndexWriter对象，通过它把分好的词写到索引库中
    IndexWriter writer = new IndexWriter(directory, cfg);

    Document doc = new Document();
    Field id = new StringField(&quot;id&quot;, &quot;11&quot;, Store.YES);
    Field description = new TextField(&quot;description&quot;, &quot;测试设置BOOST值 lucene&quot;,
            Store.YES);
    // 设置boost
    description.setBoost(10.0f);
    // 把域添加到文档中
    doc.add(id);
    doc.add(description);
    writer.addDocument(doc);
    // 关闭IndexWriter
    writer.close();
}
</code></pre><h1 id="中文分词器"><a href="#中文分词器" class="headerlink" title="中文分词器"></a>中文分词器</h1><h2 id="什么是中文分词器"><a href="#什么是中文分词器" class="headerlink" title="什么是中文分词器"></a>什么是中文分词器</h2><pre><code>学过英文的都知道，英文是以单词为单位的，单词与单词之间以空格或者逗号句号隔开。
而中文则以字为单位，字又组成词，字和词再组成句子。
所以对于英文，我们可以简单以空格判断某个字符串是否为一个单词，
比如I love China，love 和 China很容易被程序区分开来；
但中文“我爱中国”就不一样了，电脑不知道“中国”是一个词语还是“爱中”是一个词语。
把中文的句子切分成有意义的词，就是中文分词，也称切词。我爱中国，分词的结果是：我 爱 中国。
</code></pre><h2 id="Lucene自带的中文分词器"><a href="#Lucene自带的中文分词器" class="headerlink" title="Lucene自带的中文分词器"></a>Lucene自带的中文分词器</h2><pre><code>StandardAnalyzer：
单字分词：就是按照中文一个字一个字地进行分词。如：“我爱中国”，
效果：“我”、“爱”、“中”、“国”。

CJKAnalyzer
二分法分词：按两个字进行切分。如：“我是中国人”，效果：“我是”、“是中”、“中国”“国人”。
</code></pre><h2 id="使用中文分词器IKAnalyzer"><a href="#使用中文分词器IKAnalyzer" class="headerlink" title="使用中文分词器IKAnalyzer"></a>使用中文分词器IKAnalyzer</h2><pre><code>IKAnalyzer继承Lucene的Analyzer抽象类，
使用IKAnalyzer和Lucene自带的分析器方法一样，将Analyzer测试代码改为IKAnalyzer测试中文分词效果。

如果使用中文分词器ik-analyzer，就在索引和搜索程序中使用一致的分词器ik-analyzer。
</code></pre><h3 id="添加jar包"><a href="#添加jar包" class="headerlink" title="添加jar包"></a>添加jar包</h3><pre><code>将 IKAnalyzer0212FF_u1.jar 导入工程
</code></pre><h3 id="修改分词器代码"><a href="#修改分词器代码" class="headerlink" title="修改分词器代码"></a>修改分词器代码</h3><pre><code>// 创建中文分词器
Analyzer analyzer = new IKAnalyzer();
</code></pre><h2 id="扩展中文词库"><a href="#扩展中文词库" class="headerlink" title="扩展中文词库"></a>扩展中文词库</h2><p>从ikanalyzer包中拷贝配置文件到classpath下。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;  
&lt;properties&gt;  

    &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;
    &lt;!-- 用户可以在这里配置自己的扩展字典 --&gt;
     &lt;entry key=&quot;ext_dict&quot;&gt;dicdata/mydict.dic&lt;/entry&gt; 
     &lt;!-- 用户可以在这里配置自己的扩展停用词字典    --&gt;
    &lt;entry key=&quot;ext_stopwords&quot;&gt;dicdata/ext_stopword.dic&lt;/entry&gt; 

&lt;/properties&gt;
</code></pre><p>如果想配置扩展词和停用词，就创建扩展词的文件和停用词的文件，文件的编码要是utf-8。</p>
<p>注意：不要用记事本保存扩展词文件和停用词文件，那样的话，格式中是含有bom的。</p>
<p>添加扩展词文件：ext.dic，在文件中添加关键字,如:</p>
<pre><code>全文搜索
路神
等等
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/lucene入门/" itemprop="url">
                  lucene入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T19:35:42+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/19/lucene入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/19/lucene入门/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是Lucene"><a href="#什么是Lucene" class="headerlink" title="什么是Lucene?"></a>什么是Lucene?</h1><pre><code>Lucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，
部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。
</code></pre><h1 id="Lucene与搜索引擎的区别"><a href="#Lucene与搜索引擎的区别" class="headerlink" title="Lucene与搜索引擎的区别"></a>Lucene与搜索引擎的区别</h1><pre><code>全文检索系统是按照全文检索理论建立起来的用于提供全文检索服务的软件系统。全文检索系统是一个可以运行的系统，
包括建立索引、处理查询返回结果集、增加索引、优化索引结构等功能。例如：百度搜索、eclipse帮助搜索、淘宝网商品搜索。

搜索引擎是全文检索技术最主要的一个应用，例如百度。搜索引擎起源于传统的信息全文检索理论，
即计算机程序通过扫描每一篇文章中的每一个词，建立以词为单位的倒排文件，
检索程序根据检索词在每一篇文章中出现的频率和每一个检索词在一篇文章中出现的概率，对包含这些检索词的文章进行排序，
最后输出排序的结果。全文检索技术是搜索引擎的核心支撑技术。

Lucene和搜索引擎不同，Lucene是一套用java写的全文检索的工具包，为应用程序提供了很多个api接口去调用，
可以简单理解为是一套实现全文检索的类库，搜索引擎是一个全文检索系统，它是一个单独运行的软件。
</code></pre><h1 id="Lucene实现全文检索的流程"><a href="#Lucene实现全文检索的流程" class="headerlink" title="Lucene实现全文检索的流程"></a>Lucene实现全文检索的流程</h1><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene.jpg" alt=""></p>
<h2 id="全文检索的流程分为两大部分：索引流程、搜索流程。"><a href="#全文检索的流程分为两大部分：索引流程、搜索流程。" class="headerlink" title="全文检索的流程分为两大部分：索引流程、搜索流程。"></a>全文检索的流程分为两大部分：索引流程、搜索流程。</h2><pre><code>索引流程：即采集数据 -&gt; 构建文档对象  -&gt; 分析文档（分词 -&gt; 创建索引。
搜索流程：即用户通过搜索界面 -&gt; 创建查询 -&gt; 执行搜索，搜索器从索引库搜索 -&gt; 渲染搜索结果。
</code></pre><h1 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h1><p>使用Lucene实现电商项目中图书类商品的索引和搜索功能。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><pre><code>Jdk环境：1.7.0_72
Ide环境：eclipse indigo
数据库环境：mysql 5.1
Lucene：4.10.3
</code></pre><h2 id="Lucene下载安装"><a href="#Lucene下载安装" class="headerlink" title="Lucene下载安装"></a>Lucene下载安装</h2><p>Lucene是开发全文检索功能的工具包，使用时从官方网站下载，并解压。</p>
<pre><code>官方网站：http://lucene.apache.org/ 
目前最新版本：5.2.1

下载地址：http://archive.apache.org/dist/lucene/java/

下载版本：4.10.3
JDK要求：1.7以上（从版本4.8开始，不支持1.7以下）
</code></pre><h2 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h2><pre><code>1.创建java工程
2.添加jar包,入门程序只需要添加以下jar包：

    mysql5.1驱动包：mysql-connector-java-5.1.7-bin.jar
    核心包：lucene-core-4.10.3.jar
    分析器通用包：lucene-analyzers-common-4.10.3.jar
    查询解析器包：lucene-queryparser-4.10.3.jar
    junit包：junit-4.9.jar
</code></pre><h1 id="索引流程"><a href="#索引流程" class="headerlink" title="索引流程"></a>索引流程</h1><p>对文档索引的过程，就是将用户要搜索的文档内容进行索引，然后把索引存储在索引库（index）中。</p>
<h2 id="为什么要采集数据"><a href="#为什么要采集数据" class="headerlink" title="为什么要采集数据?"></a>为什么要采集数据?</h2><pre><code>全文检索要搜索的数据信息格式多种多样，拿搜索引擎（百度， google）来说，
通过搜索引擎网站能搜索互联网站上的网页(html)、互联网上的音乐(mp3..)、视频(avi..)、pdf电子书等。
全文检索搜索的这些数据称为非结构化数据。
</code></pre><p>什么是非结构化数据？</p>
<pre><code>结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。
非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等。
</code></pre><p>如何对结构化数据搜索？</p>
<pre><code>由于结构化数据是固定格式，所以就可以针对固定格式的数据设计算法来搜索，
比如数据库like查询，like查询采用顺序扫描法，使用关键字匹配内容，对于内容量大的like查询速度慢。
</code></pre><p>如何对非结构化数据搜索？</p>
<pre><code>需要将所有要搜索的非结构化数据通过技术手段采集到一个固定的地方，
将这些非结构化的数据想办法组成结构化的数据，再以一定的算法去搜索。
</code></pre><h2 id="如何采集数据"><a href="#如何采集数据" class="headerlink" title="如何采集数据?"></a>如何采集数据?</h2><pre><code>采集数据技术有哪些？
1、对于互联网上网页采用http将网页抓取到本地生成html文件。 
2、如果数据在数据库中就连接数据库读取表中的数据。
3、如果数据是文件系统中的某个文件，就通过文件系统读取文件的内容。
</code></pre><h3 id="网页采集-常用solr"><a href="#网页采集-常用solr" class="headerlink" title="网页采集(常用solr)"></a>网页采集(常用solr)</h3><pre><code>因为目前搜索引擎主要搜索数据的来源是互联网，搜索引擎使用一种爬虫程序抓取网页（ 通过http抓取html网页信息），
以下是一些爬虫项目：

Solr（http://lucene.apache.org/solr） ，solr是apache的一个子项目，支持从关系数据库、xml文档中提取原始数据。

Nutch（http://lucene.apache.org/nutch）, Nutch是apache的一个子项目，
包括大规模爬虫工具，能够抓取和分辨web网站数据。

jsoup（http://jsoup.org/ ），jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。
它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。

heritrix（http://sourceforge.net/projects/archive-crawler/files/），Heritrix 是一个由 java 开发的、开源的网络爬虫，
用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。
</code></pre><h3 id="数据库采集"><a href="#数据库采集" class="headerlink" title="数据库采集"></a>数据库采集</h3><p>针对电商站内搜索功能，全文检索的数据源在数据库中，需要通过jdbc访问数据库中book表的内容。</p>
<p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_database.jpg" alt=""></p>
<h4 id="po"><a href="#po" class="headerlink" title="po"></a>po</h4><pre><code>    public class Book {
    // 图书ID
    private Integer id;
    // 图书名称
    private String name;
    // 图书价格
    private Float price;
    // 图书图片
    private String pic;
    // 图书描述
    private String description;
}
</code></pre><h4 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h4><pre><code>    public interface BookDao {
        // 图书查询
        public List&lt;Book&gt; queryBookList() throws Exception;
        }


    public class BookDaoImpl implements BookDao {

    @Override
    public List&lt;Book&gt; queryBookList() throws Exception {
        // 数据库链接
        Connection connection = null;

        // 预编译statement
        PreparedStatement preparedStatement = null;

        // 结果集
        ResultSet resultSet = null;

        // 图书列表
        List&lt;Book&gt; list = new ArrayList&lt;Book&gt;();

        try {
            // 加载数据库驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            // 连接数据库
            connection = DriverManager.getConnection(
                    &quot;jdbc:mysql://localhost:3306/lucene&quot;, &quot;root&quot;, &quot;root&quot;);

            // SQL语句
            String sql = &quot;SELECT * FROM book&quot;;
            // 创建preparedStatement
            preparedStatement = connection.prepareStatement(sql);

            // 获取结果集
            resultSet = preparedStatement.executeQuery();

            // 结果集解析
            while (resultSet.next()) {
                Book book = new Book();
                book.setId(resultSet.getInt(&quot;id&quot;));
                book.setName(resultSet.getString(&quot;name&quot;));
                book.setPrice(resultSet.getFloat(&quot;price&quot;));
                book.setPic(resultSet.getString(&quot;pic&quot;));
                book.setDescription(resultSet.getString(&quot;description&quot;));
                list.add(book);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        return list;
    }

}
</code></pre><h2 id="索引文件的逻辑结构"><a href="#索引文件的逻辑结构" class="headerlink" title="索引文件的逻辑结构"></a>索引文件的逻辑结构</h2><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_index.jpg" alt=""></p>
<pre><code>文档域：
对非结构化的数据统一格式为document文档格式，一个文档有多个field域，
不同的文档其field的个数可以不同，建议相同类型的文档包括相同的field。 
本例子一个document对应一 条 book表的记录。

索引域：
用于搜索，搜索程序将从索引域中搜索一个一个词，根据词找到对应的文档。
将Document中的Field的内容进行分词，将分好的词创建索引，索引=Field域名:词

倒排索引表

传统方法是先找到文件。如何在文件中找内容，在文件内容中匹配搜索关键字，
这种方法是顺序扫描方法，数据量大就搜索慢。

倒排索引结构是根据内容（词语）找文档，倒排索引结构也叫反向索引结构，
包括索引和文档两部分，索引即词汇表，它是在索引中匹配搜索关键字，
由于索引内容量有限并且采用固定优化算法搜索速度很快，找到了索引中的词汇，词汇与文档关联，从而最终找到了文档。
</code></pre><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>创建索引流程：<br><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_create_index.jpg" alt=""></p>
<pre><code>IndexWriter是索引过程的核心组件，通过IndexWriter可以创建新索引、更新索引、删除索引操作。
IndexWriter需要通过Directory对索引进行存储操作。

Directory描述了索引的存储位置，底层封装了I/O操作，负责对索引进行存储。
它是一个抽象类，它的子类常用的包括FSDirectory（在文件系统存储索引）、RAMDirectory（在内存存储索引）。
</code></pre><h3 id="创建Document"><a href="#创建Document" class="headerlink" title="创建Document"></a>创建Document</h3><pre><code>采集数据的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档（Document）中包括一个一个的域（Field）。
</code></pre><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>@Test
public void createIndex() throws Exception{
//1.采集数据
BookDao dao = new BookDaoImpl();
//2.采集的数据封装成dacoument对象
List&lt;Book&gt; list = dao.queryBookList();

List&lt;Document&gt; docList = new ArrayList&lt;Document&gt;();
Document doc;
for (Book book : list) {
    doc = new Document();

    //图书id
    //不分词 、 不索引、要存储
    Field idField = new StoredField(&quot;id&quot;, book.getId().toString());

    //图书名称
    //分词、索引、存储
    Field nameField = new TextField(&quot;name&quot;, book.getName().toString(),Store.YES);

    //图书价格
    //分词、索引、存储
    Field priceField = new FloatField(&quot;price&quot;, book.getPrice(),Store.YES);

    //图书图片地址
    //不分词 、 不索引、要存储
    Field picField = new StoredField(&quot;pic&quot;, book.getPic());

    //图片描述
    //分词、索引、不存储
    Field desField = new TextField(&quot;description&quot;, book.getDescription().toString(),Store.NO);

    doc.add(desField);
    doc.add(picField);
    doc.add(priceField);
    doc.add(nameField);
    doc.add(idField);

    docList.add(doc);
}
</code></pre><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><h4 id="分词过程"><a href="#分词过程" class="headerlink" title="分词过程"></a>分词过程</h4><p>在对Docuemnt中的内容索引之前需要使用分词器进行分词 ，主要过程就是分词、过虑两步。</p>
<pre><code>1.分词就是将采集到的文档内容切分成一个一个的词，具体应该说是将Document中Field的value值切分成一个一个的词。

2.过虑包括去除标点符号、去除停用词（的、是、a、an、the等）、
大写转小写、词的形还原（复数形式转成单数形参、过去式转成现在式。。。）等。 
</code></pre><p>什么是停用词？</p>
<pre><code>停用词是为节省存储空间和提高搜索效率，
搜索引擎在索引页面或处理搜索请求时会自动忽略某些字或词，这些字或词即被称为Stop Words(停用词)。

比如语气助词、副词、介词、连接词等，
通常自身并无明确的意义，只有将其放入一个完整的句子中才有一定作用，如常见的“的”、“在”、“是”、“啊”等。
</code></pre><h4 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h4><pre><code>Tokenizer是分词器，负责将reader转换为语汇单元即进行分词，
Lucene提供了很多的分词器，也可以使用第三方的分词，比如IKAnalyzer一个中文分词器。

tokenFilter是分词过滤器，负责对语汇单元进行过滤，
tokenFilter可以是一个过滤器链儿，Lucene提供了很多的分词器过滤器，比如大小写转换、去除停用词等。
</code></pre><p>如下图是语汇单元的生成过程：</p>
<p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_tokenizer.jpg" alt=""></p>
<p>比如下边的文档经过分析器分析如下：</p>
<pre><code>原文档内容:
Lucene is a Java full-text search engine.  

分析后得到的语汇单元:
lucene、java、full、text、search、engine

同一个域中相同的语汇单元（Token）对应同一个Term（词），它记录了语汇单元的内容及所在域的域名等。
不同的域中拆分出来的相同的单词对应不同的term。
相同的域中拆分出来的相同的单词对应相同的term。

例如：图书信息里面，图书名称中的java和图书描述中的java对应不同的term
</code></pre><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>    //3.进行分词
//    Analyzer analyzer = new StandardAnalyzer();
    Analyzer analyzer = new IKAnalyzer();

    //4.创建indexWriter
    //4.1创建Directory 目录流
    IndexWriterConfig indexconfig = new IndexWriterConfig(Version.LUCENE_4_10_3, analyzer);

    //Directory 是抽象类，有两个实现类，FSDirectory(文件系统) RAMDirectory(内存)
    Directory directory = FSDirectory.open(new File(&quot;F:\\index&quot;));
    IndexWriter writer = new IndexWriter(directory,indexconfig);

    //5.通过inexWriter将document对象写入索引库
    for (Document document : docList) {
        writer.addDocument(document);
    }
    //6.关闭IndexWriter
    writer.close();
}
</code></pre><h2 id="搜索流程"><a href="#搜索流程" class="headerlink" title="搜索流程"></a>搜索流程</h2><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_IndexSearch.jpg" alt=""></p>
<pre><code>1、用户定义查询语句，用户确定查询什么内容（输入什么关键字）,指定查询语法，相当于sql语句。
2、IndexSearcher索引搜索对象，定义了很多搜索方法，程序员调用此方法搜索。
3、IndexReader索引读取对象，它对应的索引维护对象IndexWriter，IndexSearcher通过IndexReader读取索引目录中的索引文件
4、Directory索引流对象，IndexReader需要Directory读取索引库，使用FSDirectory文件系统流对象
5、IndexSearcher搜索完成，返回一个TopDocs（匹配度高的前边的一些记录）
</code></pre><h4 id="输入查询语句"><a href="#输入查询语句" class="headerlink" title="输入查询语句"></a>输入查询语句</h4><pre><code>同数据库的sql一样，lucene全文检索也有固定的语法：
最基本的有比如：AND, OR, NOT 等

用户想找一个description中包括java关键字和lucene关键字的文档。
它对应的查询语句：description:java AND lucene
</code></pre><h4 id="搜索分词"><a href="#搜索分词" class="headerlink" title="搜索分词"></a>搜索分词</h4><pre><code>和索引过程的分词一样，这里要对用户输入的关键字进行分词，一般情况索引和搜索使用的分词器一致。
比如：输入搜索关键字“java培训”，分词后为java和培训两个词，与java和培训有关的内容都搜索出来了。
</code></pre><h4 id="搜索索引"><a href="#搜索索引" class="headerlink" title="搜索索引"></a>搜索索引</h4><pre><code>根据关键字从索引中找到对应的索引信息，即词term。term与document相关联，
找到了term就找到了关联的document，从document取出Field中的信息即是要搜索的信息。
</code></pre><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>    private void doSearch(Query query) {

    try {
        // 2.创建搜索器IndexSearch
        // 2.1创建IndexReader
        Directory directory = FSDirectory.open(new File(&quot;F:\\index&quot;));
        IndexReader reader = DirectoryReader.open(directory);
        // 2.2创建Directroy

        IndexSearcher searcher = new IndexSearcher(reader);

        // 3.通过indexSearch来查询索引库
        TopDocs topDocs;
        topDocs = searcher.search(query, 10);
        // 4.处理结果
        // 根据匹配条件查询出来的数据总数
        long count = topDocs.totalHits;
        System.out.println(&quot;根据匹配条件查询出来的数据总数: &quot; + count);

        ScoreDoc[] scoreDocs = topDocs.scoreDocs;
        for (ScoreDoc scoreDoc : scoreDocs) {
            int docId = scoreDoc.doc;
            Document doc = searcher.doc(docId);
            System.out.println(&quot;商品Id: &quot; + doc.get(&quot;id&quot;));
            System.out.println(&quot;商品名称: &quot; + doc.get(&quot;name&quot;));
            System.out.println(&quot;商品价格: &quot; + doc.get(&quot;price&quot;));
            System.out.println(&quot;商品pic: &quot; + doc.get(&quot;pic&quot;));
        }
        // 5.关闭IndexReader
        reader.close();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}


    @Test
    public void search() throws ParseException, IOException {
        // 1.创建查询对象
        // 1.1创建QueryParser对象

        Analyzer analyzer = new StandardAnalyzer();
        // 默认搜索的域的域名
        String field = &quot;name&quot;;
        QueryParser parser = new QueryParser(field, analyzer);
        Query query = parser.parse(&quot;name: 花&quot;);

        doSearch(query);

    }
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/18/全文搜索引擎lucene/" itemprop="url">
                  全文搜索引擎和lucene
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-18T19:21:01+08:00" content="2016-09-18">
              2016-09-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/18/全文搜索引擎lucene/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/18/全文搜索引擎lucene/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="全文搜索简介"><a href="#全文搜索简介" class="headerlink" title="全文搜索简介"></a>全文搜索简介</h1><pre><code>全文检索首先将要查询的目标文档中的词提取出来，组成索引，通过查询索引达到搜索目标文档的目的。
这种先建立索引，再对索引进行搜索的过程就叫全文检索（Full-text Search）。
</code></pre><h1 id="搜索引擎和站内搜索的区别"><a href="#搜索引擎和站内搜索的区别" class="headerlink" title="搜索引擎和站内搜索的区别"></a>搜索引擎和站内搜索的区别</h1><pre><code>搜索引擎搜索的内容是全互联网各种类型的数据。

站内搜索搜索的内容只是本站内的信息，比如电商网站，搜索的功能，只会搜索本网站的商品信息。
</code></pre><h1 id="全文检索详解"><a href="#全文检索详解" class="headerlink" title="全文检索详解"></a>全文检索详解</h1><pre><code>全文检索是一种将文件中所有文本与检索项匹配的检索方法。它可以根据需要获得全文中有关章、节、段、句、词等信息。
计算机程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，
当用户查询时根据建立的索引查找，类似于通过字典的检索字表查字的过程。 

经过几年的发展，全文检索从最初的字符串匹配程序已经演进到能对超大文本、语音、图像、活动影像等
非结构化数据进行综合管理的大型软件。本教程只讨论文本检索。

主要应用领域：搜索引擎（百度，搜狗）、站内搜索（微博搜索）、电商网站（京东，淘宝）
</code></pre><h1 id="Lucene和全文检索应用的区别"><a href="#Lucene和全文检索应用的区别" class="headerlink" title="Lucene和全文检索应用的区别:"></a>Lucene和全文检索应用的区别:</h1><pre><code>Lucene只是一个全文检索引擎工具包（jar包）
全文检索应用是一个可以运行在web应用服务器中，并且可以独立对外提供搜索和索引服务
</code></pre><h1 id="全文检索和数据库like查询的区别"><a href="#全文检索和数据库like查询的区别" class="headerlink" title="全文检索和数据库like查询的区别"></a>全文检索和数据库like查询的区别</h1><pre><code>数据查询通常的做法是是通过数据库模糊匹配即Like &apos;%keyword%&apos;的方式，
通过它和全文检索对比来分析数据库like模糊查询和全文检索的区别。
</code></pre><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h2><pre><code>数据库中存储的数据是结构化数据，即行数据，可以用二维表结构来逻辑表达实现的数据，
结构化数据是指具有固定格式或有限长度的数据，如数据库元数据等。
</code></pre><h2 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h2><pre><code>不方便用数据库二维逻辑表来表现的数据即称为非结构化数据，
包括所有格式的办公文档、文本、图片、标准通用标记语言下的子集XML、HTML、各类报表、图像和音频/视频信息等等。

    1.非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等。
    2.半结构数据：就是介于完全结构化数据（如关系型数据库、面向对象数据库中的数据）
      和完全无结构的数据（如声音、图像文件等）之间的数据，HTML、XML文档就属于半结构化数据，
      数据的结构和内容混在一起，没有明显的区分。
</code></pre><h1 id="搜索原理"><a href="#搜索原理" class="headerlink" title="搜索原理"></a>搜索原理</h1><h2 id="顺序扫描"><a href="#顺序扫描" class="headerlink" title="顺序扫描"></a>顺序扫描</h2><pre><code>数据库的like查询采用顺序扫描的方法匹配字符串，查找结构化数据中存在某字符串的记录，如下：
查询table表中title字段出现XXXX字符的记录。
select * from table where title like ‘%XXXX%’

windows的搜索也是顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的搜索，
对于每一个文档，从头找到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。

顺序扫描问题：如果要查询的目标数据源量大且内容多，采用顺序扫描方法查询过程较慢，
比如你有一个几十G的硬盘，如果想在上面找到一个内容包含某字符串的文件，将会非常耗时。
什么时候使用顺序扫描？对于查询的目标数据源量小、内容少的情况时采用顺序扫描是很快的。
</code></pre><h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><pre><code>对于查询目标数据源量大且内容多时，特别是如果查询的数据源为非结构化数据，这时就要采用全文检索方法进行查询。
全文检索首先将要查询的目标数据源中的一部分信息提取出来，组成索引，通过查询索引达到搜索目标数据源的目的，所以速度较快。
这种先建立索引，再对索引进行搜索的过程就叫全文检索（Full-text Search）。
</code></pre><h1 id="搜索效果"><a href="#搜索效果" class="headerlink" title="搜索效果"></a>搜索效果</h1><h2 id="匹配准确性"><a href="#匹配准确性" class="headerlink" title="匹配准确性"></a>匹配准确性</h2><pre><code>使用数据库like搜索关键字“java”会把“javascript”也查询出来，因为javascript和&apos;%java%&apos;匹配。
使用搜索引擎搜索关键字“java”不会把“javascript”查询出来，
因为在对“javascript”创建索引时不会把“java”抽取出来放在索引中，
而是把“javascript”当成一个整体放在索引中，在进行全文检索时根据“java”在索引中找不到，通过“javascript”是可以找到的。
</code></pre><h2 id="相关度排序"><a href="#相关度排序" class="headerlink" title="相关度排序"></a>相关度排序</h2><pre><code>使用数据库like搜索关键字“java”，查询结果中不会把与关键字相关度最高的记录排在最前边，
数据库的排序只能根据由高到低或按字母顺序排序。
使用搜索引擎搜索关键字“java”，查询结果中会把关键字相关度最高的记录排在最前边，
在进行全文检索时会计算哪些记录与关键字的相关度最高，最高相关度的记录会排在前边。
</code></pre><h2 id="搜索速度"><a href="#搜索速度" class="headerlink" title="搜索速度"></a>搜索速度</h2><pre><code>使用数据库like搜索，如果目标数据源记录多且内容大，查询速度慢。
使用搜索引擎搜索，速度非常快。
</code></pre><h1 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h1><h2 id="数据库like查询"><a href="#数据库like查询" class="headerlink" title="数据库like查询"></a>数据库like查询</h2><pre><code>对于数据量不大、数据结构固定的数据可采用关系数据库存储，通过关系数据库提供的模糊匹配方式查询用户需要的数据，
比如学校的学生管理系统、企业人事管理系统等。
</code></pre><h2 id="全文检索-1"><a href="#全文检索-1" class="headerlink" title="全文检索"></a>全文检索</h2><pre><code>对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，
比如百度、Google等搜索引擎、论坛站内搜索、电商网站站内搜索等。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/18/jedis连接集群/" itemprop="url">
                  jedis连接集群
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-18T18:53:08+08:00" content="2016-09-18">
              2016-09-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/18/jedis连接集群/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/18/jedis连接集群/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring配置jedis"><a href="#Spring配置jedis" class="headerlink" title="Spring配置jedis"></a>Spring配置jedis</h1><pre><code>&lt;!-- 连接池配置 --&gt;
&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
&lt;!-- 最大连接数 --&gt;
&lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt;
&lt;!-- 最大空闲连接数 --&gt;
&lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt;    
&lt;!-- 每次释放连接的最大数目 --&gt;
&lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt;
&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;
&lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt;
&lt;!-- 连接最小空闲时间 --&gt;
&lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt;
&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;
&lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt;
&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;
&lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt;
&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;
&lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt;
&lt;!-- 在空闲时检查有效性, 默认false --&gt;
&lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;
&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;
&lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt;
&lt;/bean&gt;
!-- redis集群 --&gt;
&lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt;
&lt;constructor-arg index=&quot;0&quot;&gt;
    &lt;set&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7001&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7002&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7003&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;  
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7004&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7005&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7006&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/set&gt;
&lt;/constructor-arg&gt;
&lt;constructor-arg index=&quot;1&quot; ref=&quot;jedisPoolConfig&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code>private ApplicationContext applicationContext;
@Before    
public void init() {
    applicationContext = new ClassPathXmlApplicationContext(
            &quot;classpath:applicationContext.xml&quot;);
}

// redis集群    
@Test
public void testJedisCluster() {
    JedisCluster jedisCluster = (JedisCluster) applicationContext
            .getBean(&quot;jedisCluster&quot;);

    jedisCluster.set(&quot;name&quot;, &quot;zhangsan&quot;);
    String value = jedisCluster.get(&quot;name&quot;);
    System.out.println(value);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis集群搭建/" itemprop="url">
                  服务器配置(五)redis集群搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T19:30:10+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis集群搭建/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis集群搭建/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-cluster架构图"><a href="#redis-cluster架构图" class="headerlink" title="redis-cluster架构图"></a>redis-cluster架构图</h1><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/redis_cluster.jpg" alt=""></p>
<pre><code>(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.
(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.
(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可
(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value

Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，
redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，
这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，
redis 会根据节点数量大致均等的将哈希槽映射到不同的节点
</code></pre><h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><p>集群中应该至少有三个节点，每个节点有一备份节点。需要6台服务器。<br>搭建伪分布式，需要6个redis实例。<br>搭建集群的步骤：</p>
<p>第一步：创建6个redis实例指定端口从7001到7006</p>
<pre><code>在/usr/local目录下新建一个redis-cluster目录
将/usr/local/redis0707目录下的bin复制到redis-cluster,并改名为redis01
复制多个cp -r redis01/ redis02
</code></pre><p>第二步：修改redis.conf 打开Cluster-enable yes前面的注释。</p>
<pre><code>将632行的注释打开
45行端口号分别改为7001 7002 ...... 7006
</code></pre><p>第三步：需要一个ruby脚本。在redis源码文件夹下的src目录下 redis-trib.rb<br>第四步：把redis-trib.rb文件复制到到redis-cluster目录下。</p>
<pre><code>cp redis-trib.rb /usr/local/redis-cluster/
</code></pre><p>第五步：执行ruby脚本之前，需要安装ruby环境。</p>
<pre><code>1、yum install ruby    
2、yum install rubygems
3、安装redis-trib.rb运行依赖的ruby的包。
[root@bogon ~]# gem install redis-3.0.0.gem
</code></pre><p>第六步：启动所有的redis实例。</p>
<pre><code>在/usr/local/redis-cluster 目录下新建一个startup-all.sh文件，内容如下:

cd redis01
./redis-server redis.conf
cd ..
cd redis02
./redis-server redis.conf
cd ..
cd redis03
./redis-server redis.conf
cd ..
cd redis04
./redis-server redis.conf
cd ..
cd redis05
./redis-server redis.conf
cd ..
cd redis06
./redis-server redis.conf
cd ..


在redis-cluster目录下，chmod +x startup-all.sh 修改文件权限
./start-all.sh 执行命令,启动6个redis

ps aux|grep redis 查看redis是否启动
</code></pre><p>第七步：使用redis-trib.rb创建集群。</p>
<pre><code>./redis-trib.rb create --replicas 1 115.159.93.201:7001 115.159.93.201:7002 115.159.93.201:7003 115.159.93.201:7004 115.159.93.201:7005 115.159.93.201:7006

使用客户端连接集群： ./redis-cli -h 115.159.93.201 -p 7001 -c
</code></pre><h1 id="维护节点"><a href="#维护节点" class="headerlink" title="维护节点"></a>维护节点</h1><p>集群创建成功后可以向集群中添加节点，下面是添加一个master主节点 </p>
<p>添加7007结点作为新节点:</p>
<pre><code>在/usr/local/redis-cluster
./redis-trib.rb add-node 115.159.93.201:7007 115.159.93.201:7001
</code></pre><p>查看集群状态:</p>
<pre><code>cluster info
</code></pre><p>查看集群中的节点:</p>
<pre><code>cluster nodes
</code></pre><h1 id="hash槽重新分配"><a href="#hash槽重新分配" class="headerlink" title="hash槽重新分配"></a>hash槽重新分配</h1><p>添加完主节点需要对主节点进行hash槽分配，这样该主节才可以存储数据。</p>
<p>查看集群中槽占用情况：</p>
<pre><code>cluster nodes
redis集群有16384个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占用情况。
</code></pre><p>给刚添加的7007结点分配槽:</p>
<pre><code>1.连接集群上的任意一个节点
  ./redis-trib.rb reshard 192 115.159.93.201:7001 

2.输入要分配的槽数量
  how many slots do you want to move (from 1 to 16384)? 500

3.给7007分配槽，通过cluster nodes查看7007节点的id:
  8acc53cd234cb4bcc1d4f3e0e237f2655bc9e984

4.输入源节点id:
  source node#1: all

5.输入yes开始移动槽点到目标节点
</code></pre><h1 id="添加从节点"><a href="#添加从节点" class="headerlink" title="添加从节点"></a>添加从节点</h1><p>添加7008从结点，将7008作为7007的从结点</p>
<pre><code>./redis-trib.rb add-node --slave --master-id 主节点id 新节点的ip和端口 旧节点ip和端口
./redis-trib.rb add-node --slave --master-id 8acc53cd234cb4bcc1d4f3e0e237f2655bc9e984  115.159.93.201:7008 115.159.93.201:7007
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis持久化及主从复制/" itemprop="url">
                  redis持久化及主从复制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T19:03:36+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis持久化及主从复制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis持久化及主从复制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis持久化方案"><a href="#Redis持久化方案" class="headerlink" title="Redis持久化方案"></a><strong>Redis持久化方案</strong></h1><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><pre><code>RDB方式的持久化是通过快照（snapshotting）完成的，
当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。
RDB是Redis默认采用的持久化方式。
</code></pre><p>在redis.conf配置文件中默认有此下配置：</p>
<pre><code>save 900 1
save 300 10
save 60 10000

save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系。

“save 900 1”表示15分钟（900秒钟）内至少1个键被更改则进行快照。

“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。
</code></pre><p>配置dir指定rdb快照文件的位置:</p>
<pre><code># Note that you must specify a directory here, not a file name.
dir ./
</code></pre><p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。<br>根据数据量大小与结构和服务器性能不同，这个时间也不同。<br>通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。</p>
<h2 id="RDB问题总结"><a href="#RDB问题总结" class="headerlink" title="RDB问题总结"></a>RDB问题总结</h2><pre><code>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。
这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。
如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。
</code></pre><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><pre><code>默认情况下Redis没有开启AOF（append only file）方式的持久化
</code></pre><p>可以通过修改redis.conf配置文件中的appendonly参数开启</p>
<pre><code>appendonly yes
</code></pre><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬<br>盘中的AOF文件。</p>
<p>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的。</p>
<pre><code>dir ./
</code></pre><p>默认的文件名是appendonly.aof，可以通过appendfilename参数修改：</p>
<pre><code>appendfilename appendonly.aof
</code></pre><h1 id="Redis的主从复制"><a href="#Redis的主从复制" class="headerlink" title="Redis的主从复制"></a><strong>Redis的主从复制</strong></h1><pre><code>持久化保证了即使redis服务重启也不会丢失数据，
因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，
但是当redis服务器的硬盘损坏了可能会导致数据丢失，
如果通过redis的主从复制机制就可以避免这种单点故障，如下图：
</code></pre><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/copy.jpg" alt=""></p>
<pre><code>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。
主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。
只有一个主redis，可以有多个从redis。
主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求
一个redis可以即是主又是从
</code></pre><h2 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h2><p>修改从redis服务器上的redis.conf文件</p>
<pre><code># slaveof &lt;masterip&gt; &lt;masterport&gt;
slaveof 192.168.101.3 6379
</code></pre><p>上边的配置说明当前该【从redis服务器】所对应的【主redis服务器】的IP是192.168.101.3，<br>端口是6379。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis数据类型Set命令/" itemprop="url">
                  redis数据类型Set命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T18:12:48+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis数据类型Set命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis数据类型Set命令/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-Set介绍"><a href="#Redis-Set介绍" class="headerlink" title="Redis Set介绍"></a><strong>Redis Set介绍</strong></h1><pre><code>集合中的数据是不重复且没有顺序。
集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，
由于集合类型的Redis内部是使用值为空的散列表实现，
所有这些操作的时间复杂度都为0(1)。 
Redis还提供了多个集合之间的交集、并集、差集的运算。
</code></pre><p>SADD key member [member …]  SREM key member [member …] 增加/删除元素</p>
<pre><code>127.0.0.1:6379&gt; sadd set a b c
(integer) 3
127.0.0.1:6379&gt; sadd set a
(integer) 0

127.0.0.1:6379&gt; srem set c d
(integer) 1
</code></pre><p>SMEMBERS key 获得集合中的所有元素 </p>
<pre><code>127.0.0.1:6379&gt; smembers set
1) &quot;b&quot;
2) &quot;a”
</code></pre><p>SISMEMBER key member 判断元素是否在集合中</p>
<pre><code>127.0.0.1:6379&gt; sismember set a
(integer) 1
127.0.0.1:6379&gt; sismember set h
(integer) 0
</code></pre><p>SDIFF key [key …] 集合的差集运算 A-B</p>
<pre><code>属于A并且不属于B的元素构成的集合

127.0.0.1:6379&gt; sadd setA 1 2 3
(integer) 3
127.0.0.1:6379&gt; sadd setB 2 3 4
(integer) 3
127.0.0.1:6379&gt; sdiff setA setB 
1) &quot;1&quot;
127.0.0.1:6379&gt; sdiff setB setA 
1) &quot;4&quot;
</code></pre><p>SINTER key [key …] 集合的交集运算 A ∩ B</p>
<pre><code>属于A且属于B的元素构成的集合

127.0.0.1:6379&gt; sinter setA setB 
1) &quot;2&quot;
2) &quot;3&quot;
</code></pre><p>SUNION key [key …] 集合的并集运算 A ∪ B</p>
<pre><code>属于A或者属于B的元素构成的集合

127.0.0.1:6379&gt; sunion setA setB
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
</code></pre><p>SCARD key 获得集合中元素的个数</p>
<pre><code>127.0.0.1:6379&gt; smembers setA 
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
127.0.0.1:6379&gt; scard setA 
(integer) 3
</code></pre><p>SPOP key 从集合中弹出一个元素</p>
<pre><code>由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出
127.0.0.1:6379&gt; spop setA 
&quot;1&quot;
</code></pre><h1 id="SortedSet类型zset"><a href="#SortedSet类型zset" class="headerlink" title="SortedSet类型zset"></a><strong>SortedSet类型zset</strong></h1><pre><code>在集合类型的基础上，有序集合类型为集合中的每个元素都关联一个分数，
这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，
还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 
</code></pre><p>在某些方面有序集合和列表类型有些相似。 </p>
<pre><code>1、二者都是有序的。 
2、二者都可以获得某一范围的元素。 
</code></pre><p>但是，二者有着很大区别： </p>
<pre><code>1、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 
2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 
3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现） 
4、有序集合要比列表类型更耗内存。 
</code></pre><p>ZADD key score member [score member …] 增加元素</p>
<pre><code>向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。
返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 

127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu 
(integer) 3
127.0.0.1:6379&gt; zadd scoreboard 97 lisi 
(integer) 0
</code></pre><p>ZSCORE key member    获取元素的分数 </p>
<pre><code>127.0.0.1:6379&gt; zscore scoreboard lisi 
&quot;97&quot;
</code></pre><p>ZREM key member [member …] 删除元素</p>
<pre><code>移除有序集key中的一个或多个成员，不存在的成员将被忽略。
当key存在但不是有序集类型时，返回一个错误。

127.0.0.1:6379&gt; zrem scoreboard lisi
(integer) 1
</code></pre><p>ZRANGE key start stop [WITHSCORES] 获得排名在某个范围的元素列表</p>
<pre><code>按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素）

127.0.0.1:6379&gt; zrange scoreboard 0 2
1) &quot;zhangsan&quot;
2) &quot;wangwu&quot;
3) &quot;lisi“
</code></pre><p>ZREVRANGE key start stop [WITHSCORES]</p>
<pre><code>按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）

127.0.0.1:6379&gt; zrevrange scoreboard 0 2
1) &quot; lisi &quot;
2) &quot;wangwu&quot;
3) &quot; zhangsan “

如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 

127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES
1) &quot;zhangsan&quot;
2) &quot;80&quot;
3) &quot;wangwu&quot;
4) &quot;94&quot;
</code></pre><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]<br>获得指定分数范围的元素 </p>
<pre><code>127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES
1) &quot;wangwu&quot;
2) &quot;94&quot;
3) &quot;lisi&quot;
4) &quot;97&quot;
127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 2
1) &quot;wangwu&quot;
2) &quot;lisi&quot;
</code></pre><p>ZINCRBY  key increment member 增加某个元素的分数,返回值是更改后的分数 </p>
<pre><code>127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi 
&quot;101“
</code></pre><p>ZCARD key 获得集合中元素的数量 </p>
<pre><code>127.0.0.1:6379&gt; ZCARD scoreboard
(integer) 3
</code></pre><p>ZCOUNT key min max 获得指定分数范围内的元素个数</p>
<pre><code>127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90
(integer) 1
</code></pre><p>ZREMRANGEBYRANK key start stop     按照排名范围删除元素</p>
<pre><code>127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1
(integer) 2 
127.0.0.1:6379&gt; ZRANGE scoreboard 0 -1
1) &quot;lisi&quot;
</code></pre><p>ZREMRANGEBYSCORE key min max 按照分数范围删除元素</p>
<pre><code>127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan    
(integer) 1
127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100
(integer) 1
</code></pre><p>ZRANK key member 获取元素的排名 从小到大</p>
<pre><code>127.0.0.1:6379&gt; ZRANK scoreboard lisi 
(integer) 0
</code></pre><p>ZREVRANK key member 从大到小</p>
<pre><code>127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan 
(integer) 1
</code></pre><h1 id="ZSet应用"><a href="#ZSet应用" class="headerlink" title="ZSet应用"></a><strong>ZSet应用</strong></h1><h2 id="商品销售排行榜"><a href="#商品销售排行榜" class="headerlink" title="商品销售排行榜"></a>商品销售排行榜</h2><pre><code>需求：根据商品销售量对商品进行排行显示
思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。

写入商品销售量：商品编号1001的销量是9，商品编号1002的销量是10
192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002

商品编号1001的销量加1
192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001

商品销量前10名
192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis数据类型List命令/" itemprop="url">
                  redis数据类型List命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T15:02:19+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis数据类型List命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis数据类型List命令/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-list介绍"><a href="#redis-list介绍" class="headerlink" title="redis list介绍"></a><strong>redis list介绍</strong></h1><pre><code>列表类型（list）可以存储一个有序的字符串列表，
常用的操作是向列表两端添加元素，或者获得列表的某一个片段。
列表类型内部是使用双向链表（double linked list）实现的，
所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。
这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。
</code></pre><h1 id="向列表两端增加元素"><a href="#向列表两端增加元素" class="headerlink" title="向列表两端增加元素"></a>向列表两端增加元素</h1><p>LPUSH key value [value …]  向列表左边增加元素 </p>
<pre><code>127.0.0.1:6379&gt; lpush list:1 1 2 3
(integer) 3
</code></pre><p>RPUSH key value [value …]  向列表右边增加元素 </p>
<pre><code>127.0.0.1:6379&gt; rpush list:1 4 5 6
(integer) 3
</code></pre><h1 id="查看列表"><a href="#查看列表" class="headerlink" title="查看列表"></a>查看列表</h1><pre><code>LRANGE命令是列表类型最常用的命令之一，
获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），
索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。
</code></pre><p>LRANGE key start stop </p>
<pre><code>127.0.0.1:6379&gt; lrange list:1 0 2
1) &quot;2&quot;
2) &quot;1&quot;
3) &quot;4&quot;
</code></pre><h1 id="从列表两端弹出元素"><a href="#从列表两端弹出元素" class="headerlink" title="从列表两端弹出元素"></a>从列表两端弹出元素</h1><pre><code>LPOP命令从列表左边弹出一个元素，会分两步完成：
第一步是将列表左边的元素从列表中移除
第二步是返回被移除的元素值。
</code></pre><p>LPOP key </p>
<p>RPOP key</p>
<pre><code>127.0.0.1:6379&gt; lpop list:1
&quot;3“
127.0.0.1:6379&gt; rpop list:1
&quot;6“
</code></pre><h1 id="获取列表中元素的个数"><a href="#获取列表中元素的个数" class="headerlink" title="获取列表中元素的个数"></a>获取列表中元素的个数</h1><pre><code>127.0.0.1:6379&gt; llen list:1
(integer) 2
</code></pre><h1 id="删除列表中指定的值"><a href="#删除列表中指定的值" class="headerlink" title="删除列表中指定的值"></a>删除列表中指定的值</h1><pre><code>LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同： 
当count&gt;0时， LREM会从列表左边开始删除。 
当count&lt;0时， LREM会从列表后边开始删除。 
当count=0时， LREM删除所有值为value的元素。 

语法：LREM key count value
</code></pre><h1 id="获得-设置指定索引的元素值"><a href="#获得-设置指定索引的元素值" class="headerlink" title="获得/设置指定索引的元素值"></a>获得/设置指定索引的元素值</h1><p>LINDEX key index     获得指定索引的元素值</p>
<pre><code>127.0.0.1:6379&gt; lindex l:list 2
&quot;1&quot;
</code></pre><p>LSET key index value      设置指定索引的元素值</p>
<pre><code>127.0.0.1:6379&gt; lset l:list 2 2
OK
127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;2&quot;
4) &quot;2&quot;
</code></pre><h1 id="只保留列表指定片段"><a href="#只保留列表指定片段" class="headerlink" title="只保留列表指定片段"></a>只保留列表指定片段</h1><p>LTRIM key start stop 指定范围和LRANGE一致 </p>
<pre><code>127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;0&quot;
4) &quot;2&quot;
127.0.0.1:6379&gt; ltrim l:list 0 2
OK
127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;0&quot;
</code></pre><h1 id="向列表中插入元素"><a href="#向列表中插入元素" class="headerlink" title="向列表中插入元素"></a>向列表中插入元素</h1><pre><code>该命令首先会在列表中从左到右查找值为pivot的元素，
然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。
</code></pre><p>LINSERT key BEFORE|AFTER pivot value</p>
<pre><code>127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;2&quot;
3) &quot;1&quot;
127.0.0.1:6379&gt; linsert list after 3 4
(integer) 4
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;2&quot;
4) &quot;1&quot;
</code></pre><h1 id="将元素从一个列表转移到另一个列表中"><a href="#将元素从一个列表转移到另一个列表中" class="headerlink" title="将元素从一个列表转移到另一个列表中"></a>将元素从一个列表转移到另一个列表中</h1><p>RPOPLPUSH source destination</p>
<pre><code>127.0.0.1:6379&gt; rpoplpush list newlist 
&quot;1&quot;
127.0.0.1:6379&gt; lrange newlist 0 -1
1) &quot;1&quot;
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;2&quot;
</code></pre><h1 id="List应用"><a href="#List应用" class="headerlink" title="List应用"></a>List应用</h1><h2 id="商品评论列表"><a href="#商品评论列表" class="headerlink" title="商品评论列表"></a>商品评论列表</h2><pre><code>在Redis中创建商品评论列表
用户发布商品评论，将评论信息转成json存储到list中。
用户在页面查询评论列表，从redis中取出json数据展示到页面。
</code></pre><p>商品编号为1001的商品评论key【items: comment:1001】</p>
<pre><code>192.168.101.3:7001&gt; LPUSH items:comment:1001 &apos;{&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289}&apos;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jessyon" />
          <p class="site-author-name" itemprop="name">Jessyon</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">34</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jessyon</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jessyon"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
