<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="OneStack">
<meta property="og:url" content="http://jessyon.com/index.html">
<meta property="og:site_name" content="OneStack">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OneStack">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://jessyon.com/"/>

  <title> OneStack </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">OneStack</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">The Blog Powered By jessyon</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/lucene域、索引维护、搜索、中文分词/" itemprop="url">
                  lucene域、索引维护、搜索、中文分词
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T20:50:29+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/19/lucene域、索引维护、搜索、中文分词/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/19/lucene域、索引维护、搜索、中文分词/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/lucene入门/" itemprop="url">
                  lucene入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T19:35:42+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/19/lucene入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/19/lucene入门/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是Lucene"><a href="#什么是Lucene" class="headerlink" title="什么是Lucene?"></a>什么是Lucene?</h1><pre><code>Lucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，
部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。
</code></pre><h1 id="Lucene与搜索引擎的区别"><a href="#Lucene与搜索引擎的区别" class="headerlink" title="Lucene与搜索引擎的区别"></a>Lucene与搜索引擎的区别</h1><pre><code>全文检索系统是按照全文检索理论建立起来的用于提供全文检索服务的软件系统。全文检索系统是一个可以运行的系统，
包括建立索引、处理查询返回结果集、增加索引、优化索引结构等功能。例如：百度搜索、eclipse帮助搜索、淘宝网商品搜索。

搜索引擎是全文检索技术最主要的一个应用，例如百度。搜索引擎起源于传统的信息全文检索理论，
即计算机程序通过扫描每一篇文章中的每一个词，建立以词为单位的倒排文件，
检索程序根据检索词在每一篇文章中出现的频率和每一个检索词在一篇文章中出现的概率，对包含这些检索词的文章进行排序，
最后输出排序的结果。全文检索技术是搜索引擎的核心支撑技术。

Lucene和搜索引擎不同，Lucene是一套用java写的全文检索的工具包，为应用程序提供了很多个api接口去调用，
可以简单理解为是一套实现全文检索的类库，搜索引擎是一个全文检索系统，它是一个单独运行的软件。
</code></pre><h1 id="Lucene实现全文检索的流程"><a href="#Lucene实现全文检索的流程" class="headerlink" title="Lucene实现全文检索的流程"></a>Lucene实现全文检索的流程</h1><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene.jpg" alt=""></p>
<h2 id="全文检索的流程分为两大部分：索引流程、搜索流程。"><a href="#全文检索的流程分为两大部分：索引流程、搜索流程。" class="headerlink" title="全文检索的流程分为两大部分：索引流程、搜索流程。"></a>全文检索的流程分为两大部分：索引流程、搜索流程。</h2><pre><code>索引流程：即采集数据 -&gt; 构建文档对象  -&gt; 分析文档（分词 -&gt; 创建索引。
搜索流程：即用户通过搜索界面 -&gt; 创建查询 -&gt; 执行搜索，搜索器从索引库搜索 -&gt; 渲染搜索结果。
</code></pre><h1 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h1><p>使用Lucene实现电商项目中图书类商品的索引和搜索功能。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><pre><code>Jdk环境：1.7.0_72
Ide环境：eclipse indigo
数据库环境：mysql 5.1
Lucene：4.10.3
</code></pre><h2 id="Lucene下载安装"><a href="#Lucene下载安装" class="headerlink" title="Lucene下载安装"></a>Lucene下载安装</h2><p>Lucene是开发全文检索功能的工具包，使用时从官方网站下载，并解压。</p>
<pre><code>官方网站：http://lucene.apache.org/ 
目前最新版本：5.2.1

下载地址：http://archive.apache.org/dist/lucene/java/

下载版本：4.10.3
JDK要求：1.7以上（从版本4.8开始，不支持1.7以下）
</code></pre><h2 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h2><pre><code>1.创建java工程
2.添加jar包,入门程序只需要添加以下jar包：

    mysql5.1驱动包：mysql-connector-java-5.1.7-bin.jar
    核心包：lucene-core-4.10.3.jar
    分析器通用包：lucene-analyzers-common-4.10.3.jar
    查询解析器包：lucene-queryparser-4.10.3.jar
    junit包：junit-4.9.jar
</code></pre><h1 id="索引流程"><a href="#索引流程" class="headerlink" title="索引流程"></a>索引流程</h1><p>对文档索引的过程，就是将用户要搜索的文档内容进行索引，然后把索引存储在索引库（index）中。</p>
<h2 id="为什么要采集数据"><a href="#为什么要采集数据" class="headerlink" title="为什么要采集数据?"></a>为什么要采集数据?</h2><pre><code>全文检索要搜索的数据信息格式多种多样，拿搜索引擎（百度， google）来说，
通过搜索引擎网站能搜索互联网站上的网页(html)、互联网上的音乐(mp3..)、视频(avi..)、pdf电子书等。
全文检索搜索的这些数据称为非结构化数据。
</code></pre><p>什么是非结构化数据？</p>
<pre><code>结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。
非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等。
</code></pre><p>如何对结构化数据搜索？</p>
<pre><code>由于结构化数据是固定格式，所以就可以针对固定格式的数据设计算法来搜索，
比如数据库like查询，like查询采用顺序扫描法，使用关键字匹配内容，对于内容量大的like查询速度慢。
</code></pre><p>如何对非结构化数据搜索？</p>
<pre><code>需要将所有要搜索的非结构化数据通过技术手段采集到一个固定的地方，
将这些非结构化的数据想办法组成结构化的数据，再以一定的算法去搜索。
</code></pre><h2 id="如何采集数据"><a href="#如何采集数据" class="headerlink" title="如何采集数据?"></a>如何采集数据?</h2><pre><code>采集数据技术有哪些？
1、对于互联网上网页采用http将网页抓取到本地生成html文件。 
2、如果数据在数据库中就连接数据库读取表中的数据。
3、如果数据是文件系统中的某个文件，就通过文件系统读取文件的内容。
</code></pre><h3 id="网页采集-常用solr"><a href="#网页采集-常用solr" class="headerlink" title="网页采集(常用solr)"></a>网页采集(常用solr)</h3><pre><code>因为目前搜索引擎主要搜索数据的来源是互联网，搜索引擎使用一种爬虫程序抓取网页（ 通过http抓取html网页信息），
以下是一些爬虫项目：

Solr（http://lucene.apache.org/solr） ，solr是apache的一个子项目，支持从关系数据库、xml文档中提取原始数据。

Nutch（http://lucene.apache.org/nutch）, Nutch是apache的一个子项目，
包括大规模爬虫工具，能够抓取和分辨web网站数据。

jsoup（http://jsoup.org/ ），jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。
它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。

heritrix（http://sourceforge.net/projects/archive-crawler/files/），Heritrix 是一个由 java 开发的、开源的网络爬虫，
用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。
</code></pre><h3 id="数据库采集"><a href="#数据库采集" class="headerlink" title="数据库采集"></a>数据库采集</h3><p>针对电商站内搜索功能，全文检索的数据源在数据库中，需要通过jdbc访问数据库中book表的内容。</p>
<p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_database.jpg" alt=""></p>
<h4 id="po"><a href="#po" class="headerlink" title="po"></a>po</h4><pre><code>    public class Book {
    // 图书ID
    private Integer id;
    // 图书名称
    private String name;
    // 图书价格
    private Float price;
    // 图书图片
    private String pic;
    // 图书描述
    private String description;
}
</code></pre><h4 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h4><pre><code>    public interface BookDao {
        // 图书查询
        public List&lt;Book&gt; queryBookList() throws Exception;
        }


    public class BookDaoImpl implements BookDao {

    @Override
    public List&lt;Book&gt; queryBookList() throws Exception {
        // 数据库链接
        Connection connection = null;

        // 预编译statement
        PreparedStatement preparedStatement = null;

        // 结果集
        ResultSet resultSet = null;

        // 图书列表
        List&lt;Book&gt; list = new ArrayList&lt;Book&gt;();

        try {
            // 加载数据库驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            // 连接数据库
            connection = DriverManager.getConnection(
                    &quot;jdbc:mysql://localhost:3306/lucene&quot;, &quot;root&quot;, &quot;root&quot;);

            // SQL语句
            String sql = &quot;SELECT * FROM book&quot;;
            // 创建preparedStatement
            preparedStatement = connection.prepareStatement(sql);

            // 获取结果集
            resultSet = preparedStatement.executeQuery();

            // 结果集解析
            while (resultSet.next()) {
                Book book = new Book();
                book.setId(resultSet.getInt(&quot;id&quot;));
                book.setName(resultSet.getString(&quot;name&quot;));
                book.setPrice(resultSet.getFloat(&quot;price&quot;));
                book.setPic(resultSet.getString(&quot;pic&quot;));
                book.setDescription(resultSet.getString(&quot;description&quot;));
                list.add(book);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        return list;
    }

}
</code></pre><h2 id="索引文件的逻辑结构"><a href="#索引文件的逻辑结构" class="headerlink" title="索引文件的逻辑结构"></a>索引文件的逻辑结构</h2><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_index.jpg" alt=""></p>
<pre><code>文档域：
对非结构化的数据统一格式为document文档格式，一个文档有多个field域，
不同的文档其field的个数可以不同，建议相同类型的文档包括相同的field。 
本例子一个document对应一 条 book表的记录。

索引域：
用于搜索，搜索程序将从索引域中搜索一个一个词，根据词找到对应的文档。
将Document中的Field的内容进行分词，将分好的词创建索引，索引=Field域名:词

倒排索引表

传统方法是先找到文件。如何在文件中找内容，在文件内容中匹配搜索关键字，
这种方法是顺序扫描方法，数据量大就搜索慢。

倒排索引结构是根据内容（词语）找文档，倒排索引结构也叫反向索引结构，
包括索引和文档两部分，索引即词汇表，它是在索引中匹配搜索关键字，
由于索引内容量有限并且采用固定优化算法搜索速度很快，找到了索引中的词汇，词汇与文档关联，从而最终找到了文档。
</code></pre><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>创建索引流程：<br><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_create_index.jpg" alt=""></p>
<pre><code>IndexWriter是索引过程的核心组件，通过IndexWriter可以创建新索引、更新索引、删除索引操作。
IndexWriter需要通过Directory对索引进行存储操作。

Directory描述了索引的存储位置，底层封装了I/O操作，负责对索引进行存储。
它是一个抽象类，它的子类常用的包括FSDirectory（在文件系统存储索引）、RAMDirectory（在内存存储索引）。
</code></pre><h3 id="创建Document"><a href="#创建Document" class="headerlink" title="创建Document"></a>创建Document</h3><pre><code>采集数据的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档（Document）中包括一个一个的域（Field）。
</code></pre><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>@Test
public void createIndex() throws Exception{
//1.采集数据
BookDao dao = new BookDaoImpl();
//2.采集的数据封装成dacoument对象
List&lt;Book&gt; list = dao.queryBookList();

List&lt;Document&gt; docList = new ArrayList&lt;Document&gt;();
Document doc;
for (Book book : list) {
    doc = new Document();

    //图书id
    //不分词 、 不索引、要存储
    Field idField = new StoredField(&quot;id&quot;, book.getId().toString());

    //图书名称
    //分词、索引、存储
    Field nameField = new TextField(&quot;name&quot;, book.getName().toString(),Store.YES);

    //图书价格
    //分词、索引、存储
    Field priceField = new FloatField(&quot;price&quot;, book.getPrice(),Store.YES);

    //图书图片地址
    //不分词 、 不索引、要存储
    Field picField = new StoredField(&quot;pic&quot;, book.getPic());

    //图片描述
    //分词、索引、不存储
    Field desField = new TextField(&quot;description&quot;, book.getDescription().toString(),Store.NO);

    doc.add(desField);
    doc.add(picField);
    doc.add(priceField);
    doc.add(nameField);
    doc.add(idField);

    docList.add(doc);
}
</code></pre><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><h4 id="分词过程"><a href="#分词过程" class="headerlink" title="分词过程"></a>分词过程</h4><p>在对Docuemnt中的内容索引之前需要使用分词器进行分词 ，主要过程就是分词、过虑两步。</p>
<pre><code>1.分词就是将采集到的文档内容切分成一个一个的词，具体应该说是将Document中Field的value值切分成一个一个的词。

2.过虑包括去除标点符号、去除停用词（的、是、a、an、the等）、
大写转小写、词的形还原（复数形式转成单数形参、过去式转成现在式。。。）等。 
</code></pre><p>什么是停用词？</p>
<pre><code>停用词是为节省存储空间和提高搜索效率，
搜索引擎在索引页面或处理搜索请求时会自动忽略某些字或词，这些字或词即被称为Stop Words(停用词)。

比如语气助词、副词、介词、连接词等，
通常自身并无明确的意义，只有将其放入一个完整的句子中才有一定作用，如常见的“的”、“在”、“是”、“啊”等。
</code></pre><h4 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h4><pre><code>Tokenizer是分词器，负责将reader转换为语汇单元即进行分词，
Lucene提供了很多的分词器，也可以使用第三方的分词，比如IKAnalyzer一个中文分词器。

tokenFilter是分词过滤器，负责对语汇单元进行过滤，
tokenFilter可以是一个过滤器链儿，Lucene提供了很多的分词器过滤器，比如大小写转换、去除停用词等。
</code></pre><p>如下图是语汇单元的生成过程：</p>
<p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_tokenizer.jpg" alt=""></p>
<p>比如下边的文档经过分析器分析如下：</p>
<pre><code>原文档内容:
Lucene is a Java full-text search engine.  

分析后得到的语汇单元:
lucene、java、full、text、search、engine

同一个域中相同的语汇单元（Token）对应同一个Term（词），它记录了语汇单元的内容及所在域的域名等。
不同的域中拆分出来的相同的单词对应不同的term。
相同的域中拆分出来的相同的单词对应相同的term。

例如：图书信息里面，图书名称中的java和图书描述中的java对应不同的term
</code></pre><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>    //3.进行分词
//    Analyzer analyzer = new StandardAnalyzer();
    Analyzer analyzer = new IKAnalyzer();

    //4.创建indexWriter
    //4.1创建Directory 目录流
    IndexWriterConfig indexconfig = new IndexWriterConfig(Version.LUCENE_4_10_3, analyzer);

    //Directory 是抽象类，有两个实现类，FSDirectory(文件系统) RAMDirectory(内存)
    Directory directory = FSDirectory.open(new File(&quot;F:\\index&quot;));
    IndexWriter writer = new IndexWriter(directory,indexconfig);

    //5.通过inexWriter将document对象写入索引库
    for (Document document : docList) {
        writer.addDocument(document);
    }
    //6.关闭IndexWriter
    writer.close();
}
</code></pre><h2 id="搜索流程"><a href="#搜索流程" class="headerlink" title="搜索流程"></a>搜索流程</h2><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/lucene_IndexSearch.jpg" alt=""></p>
<pre><code>1、用户定义查询语句，用户确定查询什么内容（输入什么关键字）,指定查询语法，相当于sql语句。
2、IndexSearcher索引搜索对象，定义了很多搜索方法，程序员调用此方法搜索。
3、IndexReader索引读取对象，它对应的索引维护对象IndexWriter，IndexSearcher通过IndexReader读取索引目录中的索引文件
4、Directory索引流对象，IndexReader需要Directory读取索引库，使用FSDirectory文件系统流对象
5、IndexSearcher搜索完成，返回一个TopDocs（匹配度高的前边的一些记录）
</code></pre><h4 id="输入查询语句"><a href="#输入查询语句" class="headerlink" title="输入查询语句"></a>输入查询语句</h4><pre><code>同数据库的sql一样，lucene全文检索也有固定的语法：
最基本的有比如：AND, OR, NOT 等

用户想找一个description中包括java关键字和lucene关键字的文档。
它对应的查询语句：description:java AND lucene
</code></pre><h4 id="搜索分词"><a href="#搜索分词" class="headerlink" title="搜索分词"></a>搜索分词</h4><pre><code>和索引过程的分词一样，这里要对用户输入的关键字进行分词，一般情况索引和搜索使用的分词器一致。
比如：输入搜索关键字“java培训”，分词后为java和培训两个词，与java和培训有关的内容都搜索出来了。
</code></pre><h4 id="搜索索引"><a href="#搜索索引" class="headerlink" title="搜索索引"></a>搜索索引</h4><pre><code>根据关键字从索引中找到对应的索引信息，即词term。term与document相关联，
找到了term就找到了关联的document，从document取出Field中的信息即是要搜索的信息。
</code></pre><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>    private void doSearch(Query query) {

    try {
        // 2.创建搜索器IndexSearch
        // 2.1创建IndexReader
        Directory directory = FSDirectory.open(new File(&quot;F:\\index&quot;));
        IndexReader reader = DirectoryReader.open(directory);
        // 2.2创建Directroy

        IndexSearcher searcher = new IndexSearcher(reader);

        // 3.通过indexSearch来查询索引库
        TopDocs topDocs;
        topDocs = searcher.search(query, 10);
        // 4.处理结果
        // 根据匹配条件查询出来的数据总数
        long count = topDocs.totalHits;
        System.out.println(&quot;根据匹配条件查询出来的数据总数: &quot; + count);

        ScoreDoc[] scoreDocs = topDocs.scoreDocs;
        for (ScoreDoc scoreDoc : scoreDocs) {
            int docId = scoreDoc.doc;
            Document doc = searcher.doc(docId);
            System.out.println(&quot;商品Id: &quot; + doc.get(&quot;id&quot;));
            System.out.println(&quot;商品名称: &quot; + doc.get(&quot;name&quot;));
            System.out.println(&quot;商品价格: &quot; + doc.get(&quot;price&quot;));
            System.out.println(&quot;商品pic: &quot; + doc.get(&quot;pic&quot;));
        }
        // 5.关闭IndexReader
        reader.close();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}


    @Test
    public void search() throws ParseException, IOException {
        // 1.创建查询对象
        // 1.1创建QueryParser对象

        Analyzer analyzer = new StandardAnalyzer();
        // 默认搜索的域的域名
        String field = &quot;name&quot;;
        QueryParser parser = new QueryParser(field, analyzer);
        Query query = parser.parse(&quot;name: 花&quot;);

        doSearch(query);

    }
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/18/全文搜索引擎lucene/" itemprop="url">
                  全文搜索引擎和lucene
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-18T19:21:01+08:00" content="2016-09-18">
              2016-09-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/18/全文搜索引擎lucene/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/18/全文搜索引擎lucene/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="全文搜索简介"><a href="#全文搜索简介" class="headerlink" title="全文搜索简介"></a>全文搜索简介</h1><pre><code>全文检索首先将要查询的目标文档中的词提取出来，组成索引，通过查询索引达到搜索目标文档的目的。
这种先建立索引，再对索引进行搜索的过程就叫全文检索（Full-text Search）。
</code></pre><h1 id="搜索引擎和站内搜索的区别"><a href="#搜索引擎和站内搜索的区别" class="headerlink" title="搜索引擎和站内搜索的区别"></a>搜索引擎和站内搜索的区别</h1><pre><code>搜索引擎搜索的内容是全互联网各种类型的数据。

站内搜索搜索的内容只是本站内的信息，比如电商网站，搜索的功能，只会搜索本网站的商品信息。
</code></pre><h1 id="全文检索详解"><a href="#全文检索详解" class="headerlink" title="全文检索详解"></a>全文检索详解</h1><pre><code>全文检索是一种将文件中所有文本与检索项匹配的检索方法。它可以根据需要获得全文中有关章、节、段、句、词等信息。
计算机程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，
当用户查询时根据建立的索引查找，类似于通过字典的检索字表查字的过程。 

经过几年的发展，全文检索从最初的字符串匹配程序已经演进到能对超大文本、语音、图像、活动影像等
非结构化数据进行综合管理的大型软件。本教程只讨论文本检索。

主要应用领域：搜索引擎（百度，搜狗）、站内搜索（微博搜索）、电商网站（京东，淘宝）
</code></pre><h1 id="Lucene和全文检索应用的区别"><a href="#Lucene和全文检索应用的区别" class="headerlink" title="Lucene和全文检索应用的区别:"></a>Lucene和全文检索应用的区别:</h1><pre><code>Lucene只是一个全文检索引擎工具包（jar包）
全文检索应用是一个可以运行在web应用服务器中，并且可以独立对外提供搜索和索引服务
</code></pre><h1 id="全文检索和数据库like查询的区别"><a href="#全文检索和数据库like查询的区别" class="headerlink" title="全文检索和数据库like查询的区别"></a>全文检索和数据库like查询的区别</h1><pre><code>数据查询通常的做法是是通过数据库模糊匹配即Like &apos;%keyword%&apos;的方式，
通过它和全文检索对比来分析数据库like模糊查询和全文检索的区别。
</code></pre><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h2><pre><code>数据库中存储的数据是结构化数据，即行数据，可以用二维表结构来逻辑表达实现的数据，
结构化数据是指具有固定格式或有限长度的数据，如数据库元数据等。
</code></pre><h2 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h2><pre><code>不方便用数据库二维逻辑表来表现的数据即称为非结构化数据，
包括所有格式的办公文档、文本、图片、标准通用标记语言下的子集XML、HTML、各类报表、图像和音频/视频信息等等。

    1.非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等。
    2.半结构数据：就是介于完全结构化数据（如关系型数据库、面向对象数据库中的数据）
      和完全无结构的数据（如声音、图像文件等）之间的数据，HTML、XML文档就属于半结构化数据，
      数据的结构和内容混在一起，没有明显的区分。
</code></pre><h1 id="搜索原理"><a href="#搜索原理" class="headerlink" title="搜索原理"></a>搜索原理</h1><h2 id="顺序扫描"><a href="#顺序扫描" class="headerlink" title="顺序扫描"></a>顺序扫描</h2><pre><code>数据库的like查询采用顺序扫描的方法匹配字符串，查找结构化数据中存在某字符串的记录，如下：
查询table表中title字段出现XXXX字符的记录。
select * from table where title like ‘%XXXX%’

windows的搜索也是顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的搜索，
对于每一个文档，从头找到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。

顺序扫描问题：如果要查询的目标数据源量大且内容多，采用顺序扫描方法查询过程较慢，
比如你有一个几十G的硬盘，如果想在上面找到一个内容包含某字符串的文件，将会非常耗时。
什么时候使用顺序扫描？对于查询的目标数据源量小、内容少的情况时采用顺序扫描是很快的。
</code></pre><h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><pre><code>对于查询目标数据源量大且内容多时，特别是如果查询的数据源为非结构化数据，这时就要采用全文检索方法进行查询。
全文检索首先将要查询的目标数据源中的一部分信息提取出来，组成索引，通过查询索引达到搜索目标数据源的目的，所以速度较快。
这种先建立索引，再对索引进行搜索的过程就叫全文检索（Full-text Search）。
</code></pre><h1 id="搜索效果"><a href="#搜索效果" class="headerlink" title="搜索效果"></a>搜索效果</h1><h2 id="匹配准确性"><a href="#匹配准确性" class="headerlink" title="匹配准确性"></a>匹配准确性</h2><pre><code>使用数据库like搜索关键字“java”会把“javascript”也查询出来，因为javascript和&apos;%java%&apos;匹配。
使用搜索引擎搜索关键字“java”不会把“javascript”查询出来，
因为在对“javascript”创建索引时不会把“java”抽取出来放在索引中，
而是把“javascript”当成一个整体放在索引中，在进行全文检索时根据“java”在索引中找不到，通过“javascript”是可以找到的。
</code></pre><h2 id="相关度排序"><a href="#相关度排序" class="headerlink" title="相关度排序"></a>相关度排序</h2><pre><code>使用数据库like搜索关键字“java”，查询结果中不会把与关键字相关度最高的记录排在最前边，
数据库的排序只能根据由高到低或按字母顺序排序。
使用搜索引擎搜索关键字“java”，查询结果中会把关键字相关度最高的记录排在最前边，
在进行全文检索时会计算哪些记录与关键字的相关度最高，最高相关度的记录会排在前边。
</code></pre><h2 id="搜索速度"><a href="#搜索速度" class="headerlink" title="搜索速度"></a>搜索速度</h2><pre><code>使用数据库like搜索，如果目标数据源记录多且内容大，查询速度慢。
使用搜索引擎搜索，速度非常快。
</code></pre><h1 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h1><h2 id="数据库like查询"><a href="#数据库like查询" class="headerlink" title="数据库like查询"></a>数据库like查询</h2><pre><code>对于数据量不大、数据结构固定的数据可采用关系数据库存储，通过关系数据库提供的模糊匹配方式查询用户需要的数据，
比如学校的学生管理系统、企业人事管理系统等。
</code></pre><h2 id="全文检索-1"><a href="#全文检索-1" class="headerlink" title="全文检索"></a>全文检索</h2><pre><code>对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，
比如百度、Google等搜索引擎、论坛站内搜索、电商网站站内搜索等。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/18/jedis连接集群/" itemprop="url">
                  jedis连接集群
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-18T18:53:08+08:00" content="2016-09-18">
              2016-09-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/18/jedis连接集群/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/18/jedis连接集群/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring配置jedis"><a href="#Spring配置jedis" class="headerlink" title="Spring配置jedis"></a>Spring配置jedis</h1><pre><code>&lt;!-- 连接池配置 --&gt;
&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
&lt;!-- 最大连接数 --&gt;
&lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt;
&lt;!-- 最大空闲连接数 --&gt;
&lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt;    
&lt;!-- 每次释放连接的最大数目 --&gt;
&lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt;
&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;
&lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt;
&lt;!-- 连接最小空闲时间 --&gt;
&lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt;
&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;
&lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt;
&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;
&lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt;
&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;
&lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt;
&lt;!-- 在空闲时检查有效性, 默认false --&gt;
&lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;
&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;
&lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt;
&lt;/bean&gt;
!-- redis集群 --&gt;
&lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt;
&lt;constructor-arg index=&quot;0&quot;&gt;
    &lt;set&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7001&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7002&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7003&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;  
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7004&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7005&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7006&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/set&gt;
&lt;/constructor-arg&gt;
&lt;constructor-arg index=&quot;1&quot; ref=&quot;jedisPoolConfig&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code>private ApplicationContext applicationContext;
@Before    
public void init() {
    applicationContext = new ClassPathXmlApplicationContext(
            &quot;classpath:applicationContext.xml&quot;);
}

// redis集群    
@Test
public void testJedisCluster() {
    JedisCluster jedisCluster = (JedisCluster) applicationContext
            .getBean(&quot;jedisCluster&quot;);

    jedisCluster.set(&quot;name&quot;, &quot;zhangsan&quot;);
    String value = jedisCluster.get(&quot;name&quot;);
    System.out.println(value);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis集群搭建/" itemprop="url">
                  服务器配置(五)redis集群搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T19:30:10+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis集群搭建/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis集群搭建/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-cluster架构图"><a href="#redis-cluster架构图" class="headerlink" title="redis-cluster架构图"></a>redis-cluster架构图</h1><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/redis_cluster.jpg" alt=""></p>
<pre><code>(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.
(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.
(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可
(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value

Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，
redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，
这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，
redis 会根据节点数量大致均等的将哈希槽映射到不同的节点
</code></pre><h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><p>集群中应该至少有三个节点，每个节点有一备份节点。需要6台服务器。<br>搭建伪分布式，需要6个redis实例。<br>搭建集群的步骤：</p>
<p>第一步：创建6个redis实例指定端口从7001到7006</p>
<pre><code>在/usr/local目录下新建一个redis-cluster目录
将/usr/local/redis0707目录下的bin复制到redis-cluster,并改名为redis01
复制多个cp -r redis01/ redis02
</code></pre><p>第二步：修改redis.conf 打开Cluster-enable yes前面的注释。</p>
<pre><code>将632行的注释打开
45行端口号分别改为7001 7002 ...... 7006
</code></pre><p>第三步：需要一个ruby脚本。在redis源码文件夹下的src目录下 redis-trib.rb<br>第四步：把redis-trib.rb文件复制到到redis-cluster目录下。</p>
<pre><code>cp redis-trib.rb /usr/local/redis-cluster/
</code></pre><p>第五步：执行ruby脚本之前，需要安装ruby环境。</p>
<pre><code>1、yum install ruby    
2、yum install rubygems
3、安装redis-trib.rb运行依赖的ruby的包。
[root@bogon ~]# gem install redis-3.0.0.gem
</code></pre><p>第六步：启动所有的redis实例。</p>
<pre><code>在/usr/local/redis-cluster 目录下新建一个startup-all.sh文件，内容如下:

cd redis01
./redis-server redis.conf
cd ..
cd redis02
./redis-server redis.conf
cd ..
cd redis03
./redis-server redis.conf
cd ..
cd redis04
./redis-server redis.conf
cd ..
cd redis05
./redis-server redis.conf
cd ..
cd redis06
./redis-server redis.conf
cd ..


在redis-cluster目录下，chmod +x startup-all.sh 修改文件权限
./start-all.sh 执行命令,启动6个redis

ps aux|grep redis 查看redis是否启动
</code></pre><p>第七步：使用redis-trib.rb创建集群。</p>
<pre><code>./redis-trib.rb create --replicas 1 115.159.93.201:7001 115.159.93.201:7002 115.159.93.201:7003 115.159.93.201:7004 115.159.93.201:7005 115.159.93.201:7006

使用客户端连接集群： ./redis-cli -h 115.159.93.201 -p 7001 -c
</code></pre><h1 id="维护节点"><a href="#维护节点" class="headerlink" title="维护节点"></a>维护节点</h1><p>集群创建成功后可以向集群中添加节点，下面是添加一个master主节点 </p>
<p>添加7007结点作为新节点:</p>
<pre><code>在/usr/local/redis-cluster
./redis-trib.rb add-node 115.159.93.201:7007 115.159.93.201:7001
</code></pre><p>查看集群状态:</p>
<pre><code>cluster info
</code></pre><p>查看集群中的节点:</p>
<pre><code>cluster nodes
</code></pre><h1 id="hash槽重新分配"><a href="#hash槽重新分配" class="headerlink" title="hash槽重新分配"></a>hash槽重新分配</h1><p>添加完主节点需要对主节点进行hash槽分配，这样该主节才可以存储数据。</p>
<p>查看集群中槽占用情况：</p>
<pre><code>cluster nodes
redis集群有16384个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占用情况。
</code></pre><p>给刚添加的7007结点分配槽:</p>
<pre><code>1.连接集群上的任意一个节点
  ./redis-trib.rb reshard 192 115.159.93.201:7001 

2.输入要分配的槽数量
  how many slots do you want to move (from 1 to 16384)? 500

3.给7007分配槽，通过cluster nodes查看7007节点的id:
  8acc53cd234cb4bcc1d4f3e0e237f2655bc9e984

4.输入源节点id:
  source node#1: all

5.输入yes开始移动槽点到目标节点
</code></pre><h1 id="添加从节点"><a href="#添加从节点" class="headerlink" title="添加从节点"></a>添加从节点</h1><p>添加7008从结点，将7008作为7007的从结点</p>
<pre><code>./redis-trib.rb add-node --slave --master-id 主节点id 新节点的ip和端口 旧节点ip和端口
./redis-trib.rb add-node --slave --master-id 8acc53cd234cb4bcc1d4f3e0e237f2655bc9e984  115.159.93.201:7008 115.159.93.201:7007
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis持久化及主从复制/" itemprop="url">
                  redis持久化及主从复制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T19:03:36+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis持久化及主从复制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis持久化及主从复制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis持久化方案"><a href="#Redis持久化方案" class="headerlink" title="Redis持久化方案"></a><strong>Redis持久化方案</strong></h1><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><pre><code>RDB方式的持久化是通过快照（snapshotting）完成的，
当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。
RDB是Redis默认采用的持久化方式。
</code></pre><p>在redis.conf配置文件中默认有此下配置：</p>
<pre><code>save 900 1
save 300 10
save 60 10000

save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系。

“save 900 1”表示15分钟（900秒钟）内至少1个键被更改则进行快照。

“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。
</code></pre><p>配置dir指定rdb快照文件的位置:</p>
<pre><code># Note that you must specify a directory here, not a file name.
dir ./
</code></pre><p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。<br>根据数据量大小与结构和服务器性能不同，这个时间也不同。<br>通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。</p>
<h2 id="RDB问题总结"><a href="#RDB问题总结" class="headerlink" title="RDB问题总结"></a>RDB问题总结</h2><pre><code>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。
这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。
如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。
</code></pre><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><pre><code>默认情况下Redis没有开启AOF（append only file）方式的持久化
</code></pre><p>可以通过修改redis.conf配置文件中的appendonly参数开启</p>
<pre><code>appendonly yes
</code></pre><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬<br>盘中的AOF文件。</p>
<p>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的。</p>
<pre><code>dir ./
</code></pre><p>默认的文件名是appendonly.aof，可以通过appendfilename参数修改：</p>
<pre><code>appendfilename appendonly.aof
</code></pre><h1 id="Redis的主从复制"><a href="#Redis的主从复制" class="headerlink" title="Redis的主从复制"></a><strong>Redis的主从复制</strong></h1><pre><code>持久化保证了即使redis服务重启也不会丢失数据，
因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，
但是当redis服务器的硬盘损坏了可能会导致数据丢失，
如果通过redis的主从复制机制就可以避免这种单点故障，如下图：
</code></pre><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/copy.jpg" alt=""></p>
<pre><code>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。
主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。
只有一个主redis，可以有多个从redis。
主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求
一个redis可以即是主又是从
</code></pre><h2 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h2><p>修改从redis服务器上的redis.conf文件</p>
<pre><code># slaveof &lt;masterip&gt; &lt;masterport&gt;
slaveof 192.168.101.3 6379
</code></pre><p>上边的配置说明当前该【从redis服务器】所对应的【主redis服务器】的IP是192.168.101.3，<br>端口是6379。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis数据类型Set命令/" itemprop="url">
                  redis数据类型Set命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T18:12:48+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis数据类型Set命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis数据类型Set命令/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-Set介绍"><a href="#Redis-Set介绍" class="headerlink" title="Redis Set介绍"></a><strong>Redis Set介绍</strong></h1><pre><code>集合中的数据是不重复且没有顺序。
集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，
由于集合类型的Redis内部是使用值为空的散列表实现，
所有这些操作的时间复杂度都为0(1)。 
Redis还提供了多个集合之间的交集、并集、差集的运算。
</code></pre><p>SADD key member [member …]  SREM key member [member …] 增加/删除元素</p>
<pre><code>127.0.0.1:6379&gt; sadd set a b c
(integer) 3
127.0.0.1:6379&gt; sadd set a
(integer) 0

127.0.0.1:6379&gt; srem set c d
(integer) 1
</code></pre><p>SMEMBERS key 获得集合中的所有元素 </p>
<pre><code>127.0.0.1:6379&gt; smembers set
1) &quot;b&quot;
2) &quot;a”
</code></pre><p>SISMEMBER key member 判断元素是否在集合中</p>
<pre><code>127.0.0.1:6379&gt; sismember set a
(integer) 1
127.0.0.1:6379&gt; sismember set h
(integer) 0
</code></pre><p>SDIFF key [key …] 集合的差集运算 A-B</p>
<pre><code>属于A并且不属于B的元素构成的集合

127.0.0.1:6379&gt; sadd setA 1 2 3
(integer) 3
127.0.0.1:6379&gt; sadd setB 2 3 4
(integer) 3
127.0.0.1:6379&gt; sdiff setA setB 
1) &quot;1&quot;
127.0.0.1:6379&gt; sdiff setB setA 
1) &quot;4&quot;
</code></pre><p>SINTER key [key …] 集合的交集运算 A ∩ B</p>
<pre><code>属于A且属于B的元素构成的集合

127.0.0.1:6379&gt; sinter setA setB 
1) &quot;2&quot;
2) &quot;3&quot;
</code></pre><p>SUNION key [key …] 集合的并集运算 A ∪ B</p>
<pre><code>属于A或者属于B的元素构成的集合

127.0.0.1:6379&gt; sunion setA setB
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
</code></pre><p>SCARD key 获得集合中元素的个数</p>
<pre><code>127.0.0.1:6379&gt; smembers setA 
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
127.0.0.1:6379&gt; scard setA 
(integer) 3
</code></pre><p>SPOP key 从集合中弹出一个元素</p>
<pre><code>由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出
127.0.0.1:6379&gt; spop setA 
&quot;1&quot;
</code></pre><h1 id="SortedSet类型zset"><a href="#SortedSet类型zset" class="headerlink" title="SortedSet类型zset"></a><strong>SortedSet类型zset</strong></h1><pre><code>在集合类型的基础上，有序集合类型为集合中的每个元素都关联一个分数，
这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，
还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 
</code></pre><p>在某些方面有序集合和列表类型有些相似。 </p>
<pre><code>1、二者都是有序的。 
2、二者都可以获得某一范围的元素。 
</code></pre><p>但是，二者有着很大区别： </p>
<pre><code>1、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 
2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 
3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现） 
4、有序集合要比列表类型更耗内存。 
</code></pre><p>ZADD key score member [score member …] 增加元素</p>
<pre><code>向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。
返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 

127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu 
(integer) 3
127.0.0.1:6379&gt; zadd scoreboard 97 lisi 
(integer) 0
</code></pre><p>ZSCORE key member    获取元素的分数 </p>
<pre><code>127.0.0.1:6379&gt; zscore scoreboard lisi 
&quot;97&quot;
</code></pre><p>ZREM key member [member …] 删除元素</p>
<pre><code>移除有序集key中的一个或多个成员，不存在的成员将被忽略。
当key存在但不是有序集类型时，返回一个错误。

127.0.0.1:6379&gt; zrem scoreboard lisi
(integer) 1
</code></pre><p>ZRANGE key start stop [WITHSCORES] 获得排名在某个范围的元素列表</p>
<pre><code>按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素）

127.0.0.1:6379&gt; zrange scoreboard 0 2
1) &quot;zhangsan&quot;
2) &quot;wangwu&quot;
3) &quot;lisi“
</code></pre><p>ZREVRANGE key start stop [WITHSCORES]</p>
<pre><code>按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）

127.0.0.1:6379&gt; zrevrange scoreboard 0 2
1) &quot; lisi &quot;
2) &quot;wangwu&quot;
3) &quot; zhangsan “

如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 

127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES
1) &quot;zhangsan&quot;
2) &quot;80&quot;
3) &quot;wangwu&quot;
4) &quot;94&quot;
</code></pre><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]<br>获得指定分数范围的元素 </p>
<pre><code>127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES
1) &quot;wangwu&quot;
2) &quot;94&quot;
3) &quot;lisi&quot;
4) &quot;97&quot;
127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 2
1) &quot;wangwu&quot;
2) &quot;lisi&quot;
</code></pre><p>ZINCRBY  key increment member 增加某个元素的分数,返回值是更改后的分数 </p>
<pre><code>127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi 
&quot;101“
</code></pre><p>ZCARD key 获得集合中元素的数量 </p>
<pre><code>127.0.0.1:6379&gt; ZCARD scoreboard
(integer) 3
</code></pre><p>ZCOUNT key min max 获得指定分数范围内的元素个数</p>
<pre><code>127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90
(integer) 1
</code></pre><p>ZREMRANGEBYRANK key start stop     按照排名范围删除元素</p>
<pre><code>127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1
(integer) 2 
127.0.0.1:6379&gt; ZRANGE scoreboard 0 -1
1) &quot;lisi&quot;
</code></pre><p>ZREMRANGEBYSCORE key min max 按照分数范围删除元素</p>
<pre><code>127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan    
(integer) 1
127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100
(integer) 1
</code></pre><p>ZRANK key member 获取元素的排名 从小到大</p>
<pre><code>127.0.0.1:6379&gt; ZRANK scoreboard lisi 
(integer) 0
</code></pre><p>ZREVRANK key member 从大到小</p>
<pre><code>127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan 
(integer) 1
</code></pre><h1 id="ZSet应用"><a href="#ZSet应用" class="headerlink" title="ZSet应用"></a><strong>ZSet应用</strong></h1><h2 id="商品销售排行榜"><a href="#商品销售排行榜" class="headerlink" title="商品销售排行榜"></a>商品销售排行榜</h2><pre><code>需求：根据商品销售量对商品进行排行显示
思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。

写入商品销售量：商品编号1001的销量是9，商品编号1002的销量是10
192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002

商品编号1001的销量加1
192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001

商品销量前10名
192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis数据类型List命令/" itemprop="url">
                  redis数据类型List命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T15:02:19+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis数据类型List命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis数据类型List命令/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-list介绍"><a href="#redis-list介绍" class="headerlink" title="redis list介绍"></a><strong>redis list介绍</strong></h1><pre><code>列表类型（list）可以存储一个有序的字符串列表，
常用的操作是向列表两端添加元素，或者获得列表的某一个片段。
列表类型内部是使用双向链表（double linked list）实现的，
所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。
这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。
</code></pre><h1 id="向列表两端增加元素"><a href="#向列表两端增加元素" class="headerlink" title="向列表两端增加元素"></a>向列表两端增加元素</h1><p>LPUSH key value [value …]  向列表左边增加元素 </p>
<pre><code>127.0.0.1:6379&gt; lpush list:1 1 2 3
(integer) 3
</code></pre><p>RPUSH key value [value …]  向列表右边增加元素 </p>
<pre><code>127.0.0.1:6379&gt; rpush list:1 4 5 6
(integer) 3
</code></pre><h1 id="查看列表"><a href="#查看列表" class="headerlink" title="查看列表"></a>查看列表</h1><pre><code>LRANGE命令是列表类型最常用的命令之一，
获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），
索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。
</code></pre><p>LRANGE key start stop </p>
<pre><code>127.0.0.1:6379&gt; lrange list:1 0 2
1) &quot;2&quot;
2) &quot;1&quot;
3) &quot;4&quot;
</code></pre><h1 id="从列表两端弹出元素"><a href="#从列表两端弹出元素" class="headerlink" title="从列表两端弹出元素"></a>从列表两端弹出元素</h1><pre><code>LPOP命令从列表左边弹出一个元素，会分两步完成：
第一步是将列表左边的元素从列表中移除
第二步是返回被移除的元素值。
</code></pre><p>LPOP key </p>
<p>RPOP key</p>
<pre><code>127.0.0.1:6379&gt; lpop list:1
&quot;3“
127.0.0.1:6379&gt; rpop list:1
&quot;6“
</code></pre><h1 id="获取列表中元素的个数"><a href="#获取列表中元素的个数" class="headerlink" title="获取列表中元素的个数"></a>获取列表中元素的个数</h1><pre><code>127.0.0.1:6379&gt; llen list:1
(integer) 2
</code></pre><h1 id="删除列表中指定的值"><a href="#删除列表中指定的值" class="headerlink" title="删除列表中指定的值"></a>删除列表中指定的值</h1><pre><code>LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同： 
当count&gt;0时， LREM会从列表左边开始删除。 
当count&lt;0时， LREM会从列表后边开始删除。 
当count=0时， LREM删除所有值为value的元素。 

语法：LREM key count value
</code></pre><h1 id="获得-设置指定索引的元素值"><a href="#获得-设置指定索引的元素值" class="headerlink" title="获得/设置指定索引的元素值"></a>获得/设置指定索引的元素值</h1><p>LINDEX key index     获得指定索引的元素值</p>
<pre><code>127.0.0.1:6379&gt; lindex l:list 2
&quot;1&quot;
</code></pre><p>LSET key index value      设置指定索引的元素值</p>
<pre><code>127.0.0.1:6379&gt; lset l:list 2 2
OK
127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;2&quot;
4) &quot;2&quot;
</code></pre><h1 id="只保留列表指定片段"><a href="#只保留列表指定片段" class="headerlink" title="只保留列表指定片段"></a>只保留列表指定片段</h1><p>LTRIM key start stop 指定范围和LRANGE一致 </p>
<pre><code>127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;0&quot;
4) &quot;2&quot;
127.0.0.1:6379&gt; ltrim l:list 0 2
OK
127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;0&quot;
</code></pre><h1 id="向列表中插入元素"><a href="#向列表中插入元素" class="headerlink" title="向列表中插入元素"></a>向列表中插入元素</h1><pre><code>该命令首先会在列表中从左到右查找值为pivot的元素，
然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。
</code></pre><p>LINSERT key BEFORE|AFTER pivot value</p>
<pre><code>127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;2&quot;
3) &quot;1&quot;
127.0.0.1:6379&gt; linsert list after 3 4
(integer) 4
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;2&quot;
4) &quot;1&quot;
</code></pre><h1 id="将元素从一个列表转移到另一个列表中"><a href="#将元素从一个列表转移到另一个列表中" class="headerlink" title="将元素从一个列表转移到另一个列表中"></a>将元素从一个列表转移到另一个列表中</h1><p>RPOPLPUSH source destination</p>
<pre><code>127.0.0.1:6379&gt; rpoplpush list newlist 
&quot;1&quot;
127.0.0.1:6379&gt; lrange newlist 0 -1
1) &quot;1&quot;
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;2&quot;
</code></pre><h1 id="List应用"><a href="#List应用" class="headerlink" title="List应用"></a>List应用</h1><h2 id="商品评论列表"><a href="#商品评论列表" class="headerlink" title="商品评论列表"></a>商品评论列表</h2><pre><code>在Redis中创建商品评论列表
用户发布商品评论，将评论信息转成json存储到list中。
用户在页面查询评论列表，从redis中取出json数据展示到页面。
</code></pre><p>商品编号为1001的商品评论key【items: comment:1001】</p>
<pre><code>192.168.101.3:7001&gt; LPUSH items:comment:1001 &apos;{&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289}&apos;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis数据类型Hash命令/" itemprop="url">
                  redis数据类型Hash命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T14:36:40+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis数据类型Hash命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis数据类型Hash命令/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a><strong>Hash类型</strong></h1><p>hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下：<br><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/redis_hash.jpg" alt=""></p>
<h1 id="Hash命令"><a href="#Hash命令" class="headerlink" title="Hash命令"></a><strong>Hash命令</strong></h1><p>HSET key field value  赋值</p>
<pre><code>HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。

127.0.0.1:6379&gt; hset user username zhangsan 
(integer) 1
</code></pre><p>HMSET key field value [field value …]      一次可以设置多个字段值</p>
<pre><code>127.0.0.1:6379&gt; hmset user age 20 username lisi 
OK
</code></pre><p>HSETNX key field value  当字段不存在时赋值</p>
<pre><code>当字段不存在时赋值，类似HSET，区别在于如果字段存在，该命令不执行任何操作

127.0.0.1:6379&gt; hsetnx user age 30    
如果user中没有age字段则设置age值为30，否则不做任何操作
(integer) 0
</code></pre><p>HGET key field  一次只能获取一个字段值</p>
<pre><code>127.0.0.1:6379&gt; hget user username
&quot;zhangsan“
</code></pre><p>HMGET key field [field …]    一次可以获取多个字段值</p>
<pre><code>127.0.0.1:6379&gt; hmget user age username
1) &quot;20&quot;
2) &quot;lisi&quot;
</code></pre><p>HGETALL key     获取所有字段值</p>
<pre><code>127.0.0.1:6379&gt; hgetall user
1) &quot;age&quot;
2) &quot;20&quot;
3) &quot;username&quot;
4) &quot;lisi&quot;
</code></pre><p>HDEL key field [field …]  可以删除一个或多个字段，返回值是被删除的字段个数 </p>
<pre><code>127.0.0.1:6379&gt; hdel user age
(integer) 1
127.0.0.1:6379&gt; hdel user age name
(integer) 0
127.0.0.1:6379&gt; hdel user age username
(integer) 1 
</code></pre><p>HINCRBY key field increment     增加值</p>
<pre><code>127.0.0.1:6379&gt; hincrby user age 2    将用户的年龄加2
(integer) 22
127.0.0.1:6379&gt; hget user age        获取用户的年龄
&quot;22“
</code></pre><p>HEXISTS key field     判断字段是否存在</p>
<pre><code>127.0.0.1:6379&gt; hexists user age        查看user中是否有age字段
(integer) 1
127.0.0.1:6379&gt; hexists user name    查看user中是否有name字段
(integer) 0
</code></pre><p>HKEYS key      只获取字段名</p>
<p>HVALS key   只获取字段值</p>
<pre><code>127.0.0.1:6379&gt; hmset user age 20 name lisi 
OK
127.0.0.1:6379&gt; hkeys user
1) &quot;age&quot;
2) &quot;name&quot;
127.0.0.1:6379&gt; hvals user
1) &quot;20&quot;
2) &quot;lisi&quot;
</code></pre><p>HLEN key 获取字段长度</p>
<pre><code>127.0.0.1:6379&gt; hlen user    
(integer) 2
</code></pre><h1 id="Hash应用"><a href="#Hash应用" class="headerlink" title="Hash应用"></a><strong>Hash应用</strong></h1><h1 id="存储商品信息"><a href="#存储商品信息" class="headerlink" title="存储商品信息:"></a>存储商品信息:</h1><p>商品字段</p>
<pre><code>【商品id、商品名称、商品描述、商品库存、商品好评】
</code></pre><p>定义商品信息的key</p>
<pre><code>商品1001的信息在 Redis中的key为：[items:1001]
</code></pre><p>储商品信息</p>
<pre><code>192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9
OK
</code></pre><p>获取商品信息</p>
<pre><code>192.168.101.3:7003&gt; HGET items:1001 id
&quot;3&quot;
192.168.101.3:7003&gt; HGETALL items:1001
1) &quot;id&quot;
2) &quot;3&quot;
3) &quot;name&quot;
4) &quot;apple&quot;
5) &quot;price&quot;
6) &quot;999.9&quot;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis数据类型及string命令/" itemprop="url">
                  redis数据类型String命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T13:59:39+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis数据类型及string命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis数据类型及string命令/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><strong>String类型</strong></h1><p>SET key value 赋值</p>
<pre><code>127.0.0.1:6379&gt; set test 123
OK
</code></pre><p>GET key  取值</p>
<pre><code>127.0.0.1:6379&gt; get test
&quot;123“
</code></pre><p>GETSET key value  取值并赋值</p>
<pre><code>127.0.0.1:6379&gt; getset s2 222
&quot;111&quot;
127.0.0.1:6379&gt; get s2
&quot;222&quot;
</code></pre><p>DEL key 删除</p>
<pre><code>127.0.0.1:6379&gt; del test
(integer) 1
</code></pre><p>incr key 递增数字 </p>
<p>当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。</p>
<pre><code>127.0.0.1:6379&gt; incr num
(integer) 1
127.0.0.1:6379&gt; incr num
(integer) 2
127.0.0.1:6379&gt; incr num
(integer) 3
</code></pre><p>INCRBY key increment 增加指定的整数 </p>
<pre><code>127.0.0.1:6379&gt; incrby num 2
(integer) 5
127.0.0.1:6379&gt; incrby num 2
(integer) 7
127.0.0.1:6379&gt; incrby num 2
(integer) 9
</code></pre><p>DECR key  递减数值</p>
<pre><code>127.0.0.1:6379&gt; decr num
(integer) 9
127.0.0.1:6379&gt; decr num
(integer) 8
</code></pre><p>DECRBY key decrement      减少指定的整数 </p>
<pre><code>127.0.0.1:6379&gt; decr num
(integer) 6
127.0.0.1:6379&gt; decr num
(integer) 5
127.0.0.1:6379&gt; decrby num 3
(integer) 2
127.0.0.1:6379&gt; decrby num 3
(integer) -1
</code></pre><p>APPEND key value      向尾部追加值 </p>
<pre><code>127.0.0.1:6379&gt; set str hello
OK
127.0.0.1:6379&gt; append str &quot; world!&quot;
(integer) 12
127.0.0.1:6379&gt; get str 
&quot;hello world!&quot;
</code></pre><p>STRLEN key 获取字符串长度</p>
<pre><code>127.0.0.1:6379&gt; strlen str 
(integer) 0
127.0.0.1:6379&gt; set str hello
OK
127.0.0.1:6379&gt; strlen str 
(integer) 5
</code></pre><p>MSET key value [key value …] 同时设置多个值</p>
<pre><code>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3
OK
</code></pre><p>MGET key [key …] 同时取多个值</p>
<pre><code>127.0.0.1:6379&gt; get k1
&quot;v1&quot;
127.0.0.1:6379&gt; mget k1 k3
1) &quot;v1&quot;
2) &quot;v3&quot;
</code></pre><h1 id="String应用"><a href="#String应用" class="headerlink" title="String应用"></a><strong>String应用</strong></h1><p>自增主键:  商品编号、订单号采用string的递增数字特性生成。</p>
<pre><code>定义商品编号key：items:id
192.168.101.3:7003&gt; INCR items:id
(integer) 2
192.168.101.3:7003&gt; INCR items:id
(integer) 3
</code></pre><h1 id="String存在的问题"><a href="#String存在的问题" class="headerlink" title="String存在的问题"></a><strong>String存在的问题</strong></h1><pre><code>假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age、name等属性，存储的过程如下： 
保存、更新： 
User对象  -&gt;  json(string)  -&gt;  redis 
如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 
如果仍然采用上边的方法在传输、处理时会造成资源浪费，下边讲的hash可以很好的解决这个问题。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jessyon" />
          <p class="site-author-name" itemprop="name">Jessyon</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">32</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jessyon</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jessyon"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
