<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="OneStack">
<meta property="og:url" content="http://jessyon.com/index.html">
<meta property="og:site_name" content="OneStack">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OneStack">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://jessyon.com/"/>

  <title> OneStack </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">OneStack</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">The Blog Powered By jessyon</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/18/jedis连接集群/" itemprop="url">
                  jedis连接集群
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-18T18:53:08+08:00" content="2016-09-18">
              2016-09-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/18/jedis连接集群/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/18/jedis连接集群/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring配置jedis"><a href="#Spring配置jedis" class="headerlink" title="Spring配置jedis"></a>Spring配置jedis</h1><pre><code>&lt;!-- 连接池配置 --&gt;
&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
&lt;!-- 最大连接数 --&gt;
&lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt;
&lt;!-- 最大空闲连接数 --&gt;
&lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt;    
&lt;!-- 每次释放连接的最大数目 --&gt;
&lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt;
&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;
&lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt;
&lt;!-- 连接最小空闲时间 --&gt;
&lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt;
&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;
&lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt;
&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;
&lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt;
&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;
&lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt;
&lt;!-- 在空闲时检查有效性, 默认false --&gt;
&lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;
&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;
&lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt;
&lt;/bean&gt;
!-- redis集群 --&gt;
&lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt;
&lt;constructor-arg index=&quot;0&quot;&gt;
    &lt;set&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7001&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7002&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7003&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;  
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7004&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7005&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;115.159.93.201&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg index=&quot;1&quot; value=&quot;7006&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/set&gt;
&lt;/constructor-arg&gt;
&lt;constructor-arg index=&quot;1&quot; ref=&quot;jedisPoolConfig&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code>private ApplicationContext applicationContext;
@Before    
public void init() {
    applicationContext = new ClassPathXmlApplicationContext(
            &quot;classpath:applicationContext.xml&quot;);
}

// redis集群    
@Test
public void testJedisCluster() {
    JedisCluster jedisCluster = (JedisCluster) applicationContext
            .getBean(&quot;jedisCluster&quot;);

    jedisCluster.set(&quot;name&quot;, &quot;zhangsan&quot;);
    String value = jedisCluster.get(&quot;name&quot;);
    System.out.println(value);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis集群搭建/" itemprop="url">
                  服务器配置(五)redis集群搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T19:30:10+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis集群搭建/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis集群搭建/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-cluster架构图"><a href="#redis-cluster架构图" class="headerlink" title="redis-cluster架构图"></a>redis-cluster架构图</h1><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/redis_cluster.jpg" alt=""></p>
<pre><code>(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.
(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.
(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可
(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value

Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，
redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，
这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，
redis 会根据节点数量大致均等的将哈希槽映射到不同的节点
</code></pre><h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><p>集群中应该至少有三个节点，每个节点有一备份节点。需要6台服务器。<br>搭建伪分布式，需要6个redis实例。<br>搭建集群的步骤：</p>
<p>第一步：创建6个redis实例指定端口从7001到7006</p>
<pre><code>在/usr/local目录下新建一个redis-cluster目录
将/usr/local/redis0707目录下的bin复制到redis-cluster,并改名为redis01
复制多个cp -r redis01/ redis02
</code></pre><p>第二步：修改redis.conf 打开Cluster-enable yes前面的注释。</p>
<pre><code>将632行的注释打开
45行端口号分别改为7001 7002 ...... 7006
</code></pre><p>第三步：需要一个ruby脚本。在redis源码文件夹下的src目录下 redis-trib.rb<br>第四步：把redis-trib.rb文件复制到到redis-cluster目录下。</p>
<pre><code>cp redis-trib.rb /usr/local/redis-cluster/
</code></pre><p>第五步：执行ruby脚本之前，需要安装ruby环境。</p>
<pre><code>1、yum install ruby    
2、yum install rubygems
3、安装redis-trib.rb运行依赖的ruby的包。
[root@bogon ~]# gem install redis-3.0.0.gem
</code></pre><p>第六步：启动所有的redis实例。</p>
<pre><code>在/usr/local/redis-cluster 目录下新建一个startup-all.sh文件，内容如下:

cd redis01
./redis-server redis.conf
cd ..
cd redis02
./redis-server redis.conf
cd ..
cd redis03
./redis-server redis.conf
cd ..
cd redis04
./redis-server redis.conf
cd ..
cd redis05
./redis-server redis.conf
cd ..
cd redis06
./redis-server redis.conf
cd ..


在redis-cluster目录下，chmod +x startup-all.sh 修改文件权限
./start-all.sh 执行命令,启动6个redis

ps aux|grep redis 查看redis是否启动
</code></pre><p>第七步：使用redis-trib.rb创建集群。</p>
<pre><code>./redis-trib.rb create --replicas 1 115.159.93.201:7001 115.159.93.201:7002 115.159.93.201:7003 115.159.93.201:7004 115.159.93.201:7005 115.159.93.201:7006

使用客户端连接集群： ./redis-cli -h 115.159.93.201 -p 7001 -c
</code></pre><h1 id="维护节点"><a href="#维护节点" class="headerlink" title="维护节点"></a>维护节点</h1><p>集群创建成功后可以向集群中添加节点，下面是添加一个master主节点 </p>
<p>添加7007结点作为新节点:</p>
<pre><code>在/usr/local/redis-cluster
./redis-trib.rb add-node 115.159.93.201:7007 115.159.93.201:7001
</code></pre><p>查看集群状态:</p>
<pre><code>cluster info
</code></pre><p>查看集群中的节点:</p>
<pre><code>cluster nodes
</code></pre><h1 id="hash槽重新分配"><a href="#hash槽重新分配" class="headerlink" title="hash槽重新分配"></a>hash槽重新分配</h1><p>添加完主节点需要对主节点进行hash槽分配，这样该主节才可以存储数据。</p>
<p>查看集群中槽占用情况：</p>
<pre><code>cluster nodes
redis集群有16384个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占用情况。
</code></pre><p>给刚添加的7007结点分配槽:</p>
<pre><code>1.连接集群上的任意一个节点
  ./redis-trib.rb reshard 192 115.159.93.201:7001 

2.输入要分配的槽数量
  how many slots do you want to move (from 1 to 16384)? 500

3.给7007分配槽，通过cluster nodes查看7007节点的id:
  8acc53cd234cb4bcc1d4f3e0e237f2655bc9e984

4.输入源节点id:
  source node#1: all

5.输入yes开始移动槽点到目标节点
</code></pre><h1 id="添加从节点"><a href="#添加从节点" class="headerlink" title="添加从节点"></a>添加从节点</h1><p>添加7008从结点，将7008作为7007的从结点</p>
<pre><code>./redis-trib.rb add-node --slave --master-id 主节点id 新节点的ip和端口 旧节点ip和端口
./redis-trib.rb add-node --slave --master-id 8acc53cd234cb4bcc1d4f3e0e237f2655bc9e984  115.159.93.201:7008 115.159.93.201:7007
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis持久化及主从复制/" itemprop="url">
                  redis持久化及主从复制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T19:03:36+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis持久化及主从复制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis持久化及主从复制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis持久化方案"><a href="#Redis持久化方案" class="headerlink" title="Redis持久化方案"></a><strong>Redis持久化方案</strong></h1><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><pre><code>RDB方式的持久化是通过快照（snapshotting）完成的，
当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。
RDB是Redis默认采用的持久化方式。
</code></pre><p>在redis.conf配置文件中默认有此下配置：</p>
<pre><code>save 900 1
save 300 10
save 60 10000

save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系。

“save 900 1”表示15分钟（900秒钟）内至少1个键被更改则进行快照。

“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。
</code></pre><p>配置dir指定rdb快照文件的位置:</p>
<pre><code># Note that you must specify a directory here, not a file name.
dir ./
</code></pre><p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。<br>根据数据量大小与结构和服务器性能不同，这个时间也不同。<br>通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。</p>
<h2 id="RDB问题总结"><a href="#RDB问题总结" class="headerlink" title="RDB问题总结"></a>RDB问题总结</h2><pre><code>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。
这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。
如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。
</code></pre><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><pre><code>默认情况下Redis没有开启AOF（append only file）方式的持久化
</code></pre><p>可以通过修改redis.conf配置文件中的appendonly参数开启</p>
<pre><code>appendonly yes
</code></pre><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬<br>盘中的AOF文件。</p>
<p>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的。</p>
<pre><code>dir ./
</code></pre><p>默认的文件名是appendonly.aof，可以通过appendfilename参数修改：</p>
<pre><code>appendfilename appendonly.aof
</code></pre><h1 id="Redis的主从复制"><a href="#Redis的主从复制" class="headerlink" title="Redis的主从复制"></a><strong>Redis的主从复制</strong></h1><pre><code>持久化保证了即使redis服务重启也不会丢失数据，
因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，
但是当redis服务器的硬盘损坏了可能会导致数据丢失，
如果通过redis的主从复制机制就可以避免这种单点故障，如下图：
</code></pre><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/copy.jpg" alt=""></p>
<pre><code>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。
主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。
只有一个主redis，可以有多个从redis。
主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求
一个redis可以即是主又是从
</code></pre><h2 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h2><p>修改从redis服务器上的redis.conf文件</p>
<pre><code># slaveof &lt;masterip&gt; &lt;masterport&gt;
slaveof 192.168.101.3 6379
</code></pre><p>上边的配置说明当前该【从redis服务器】所对应的【主redis服务器】的IP是192.168.101.3，<br>端口是6379。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis数据类型Set命令/" itemprop="url">
                  redis数据类型Set命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T18:12:48+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis数据类型Set命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis数据类型Set命令/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-Set介绍"><a href="#Redis-Set介绍" class="headerlink" title="Redis Set介绍"></a><strong>Redis Set介绍</strong></h1><pre><code>集合中的数据是不重复且没有顺序。
集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，
由于集合类型的Redis内部是使用值为空的散列表实现，
所有这些操作的时间复杂度都为0(1)。 
Redis还提供了多个集合之间的交集、并集、差集的运算。
</code></pre><p>SADD key member [member …]  SREM key member [member …] 增加/删除元素</p>
<pre><code>127.0.0.1:6379&gt; sadd set a b c
(integer) 3
127.0.0.1:6379&gt; sadd set a
(integer) 0

127.0.0.1:6379&gt; srem set c d
(integer) 1
</code></pre><p>SMEMBERS key 获得集合中的所有元素 </p>
<pre><code>127.0.0.1:6379&gt; smembers set
1) &quot;b&quot;
2) &quot;a”
</code></pre><p>SISMEMBER key member 判断元素是否在集合中</p>
<pre><code>127.0.0.1:6379&gt; sismember set a
(integer) 1
127.0.0.1:6379&gt; sismember set h
(integer) 0
</code></pre><p>SDIFF key [key …] 集合的差集运算 A-B</p>
<pre><code>属于A并且不属于B的元素构成的集合

127.0.0.1:6379&gt; sadd setA 1 2 3
(integer) 3
127.0.0.1:6379&gt; sadd setB 2 3 4
(integer) 3
127.0.0.1:6379&gt; sdiff setA setB 
1) &quot;1&quot;
127.0.0.1:6379&gt; sdiff setB setA 
1) &quot;4&quot;
</code></pre><p>SINTER key [key …] 集合的交集运算 A ∩ B</p>
<pre><code>属于A且属于B的元素构成的集合

127.0.0.1:6379&gt; sinter setA setB 
1) &quot;2&quot;
2) &quot;3&quot;
</code></pre><p>SUNION key [key …] 集合的并集运算 A ∪ B</p>
<pre><code>属于A或者属于B的元素构成的集合

127.0.0.1:6379&gt; sunion setA setB
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
</code></pre><p>SCARD key 获得集合中元素的个数</p>
<pre><code>127.0.0.1:6379&gt; smembers setA 
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
127.0.0.1:6379&gt; scard setA 
(integer) 3
</code></pre><p>SPOP key 从集合中弹出一个元素</p>
<pre><code>由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出
127.0.0.1:6379&gt; spop setA 
&quot;1&quot;
</code></pre><h1 id="SortedSet类型zset"><a href="#SortedSet类型zset" class="headerlink" title="SortedSet类型zset"></a><strong>SortedSet类型zset</strong></h1><pre><code>在集合类型的基础上，有序集合类型为集合中的每个元素都关联一个分数，
这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，
还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 
</code></pre><p>在某些方面有序集合和列表类型有些相似。 </p>
<pre><code>1、二者都是有序的。 
2、二者都可以获得某一范围的元素。 
</code></pre><p>但是，二者有着很大区别： </p>
<pre><code>1、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 
2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 
3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现） 
4、有序集合要比列表类型更耗内存。 
</code></pre><p>ZADD key score member [score member …] 增加元素</p>
<pre><code>向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。
返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 

127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu 
(integer) 3
127.0.0.1:6379&gt; zadd scoreboard 97 lisi 
(integer) 0
</code></pre><p>ZSCORE key member    获取元素的分数 </p>
<pre><code>127.0.0.1:6379&gt; zscore scoreboard lisi 
&quot;97&quot;
</code></pre><p>ZREM key member [member …] 删除元素</p>
<pre><code>移除有序集key中的一个或多个成员，不存在的成员将被忽略。
当key存在但不是有序集类型时，返回一个错误。

127.0.0.1:6379&gt; zrem scoreboard lisi
(integer) 1
</code></pre><p>ZRANGE key start stop [WITHSCORES] 获得排名在某个范围的元素列表</p>
<pre><code>按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素）

127.0.0.1:6379&gt; zrange scoreboard 0 2
1) &quot;zhangsan&quot;
2) &quot;wangwu&quot;
3) &quot;lisi“
</code></pre><p>ZREVRANGE key start stop [WITHSCORES]</p>
<pre><code>按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）

127.0.0.1:6379&gt; zrevrange scoreboard 0 2
1) &quot; lisi &quot;
2) &quot;wangwu&quot;
3) &quot; zhangsan “

如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 

127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES
1) &quot;zhangsan&quot;
2) &quot;80&quot;
3) &quot;wangwu&quot;
4) &quot;94&quot;
</code></pre><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]<br>获得指定分数范围的元素 </p>
<pre><code>127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES
1) &quot;wangwu&quot;
2) &quot;94&quot;
3) &quot;lisi&quot;
4) &quot;97&quot;
127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 2
1) &quot;wangwu&quot;
2) &quot;lisi&quot;
</code></pre><p>ZINCRBY  key increment member 增加某个元素的分数,返回值是更改后的分数 </p>
<pre><code>127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi 
&quot;101“
</code></pre><p>ZCARD key 获得集合中元素的数量 </p>
<pre><code>127.0.0.1:6379&gt; ZCARD scoreboard
(integer) 3
</code></pre><p>ZCOUNT key min max 获得指定分数范围内的元素个数</p>
<pre><code>127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90
(integer) 1
</code></pre><p>ZREMRANGEBYRANK key start stop     按照排名范围删除元素</p>
<pre><code>127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1
(integer) 2 
127.0.0.1:6379&gt; ZRANGE scoreboard 0 -1
1) &quot;lisi&quot;
</code></pre><p>ZREMRANGEBYSCORE key min max 按照分数范围删除元素</p>
<pre><code>127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan    
(integer) 1
127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100
(integer) 1
</code></pre><p>ZRANK key member 获取元素的排名 从小到大</p>
<pre><code>127.0.0.1:6379&gt; ZRANK scoreboard lisi 
(integer) 0
</code></pre><p>ZREVRANK key member 从大到小</p>
<pre><code>127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan 
(integer) 1
</code></pre><h1 id="ZSet应用"><a href="#ZSet应用" class="headerlink" title="ZSet应用"></a><strong>ZSet应用</strong></h1><h2 id="商品销售排行榜"><a href="#商品销售排行榜" class="headerlink" title="商品销售排行榜"></a>商品销售排行榜</h2><pre><code>需求：根据商品销售量对商品进行排行显示
思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。

写入商品销售量：商品编号1001的销量是9，商品编号1002的销量是10
192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002

商品编号1001的销量加1
192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001

商品销量前10名
192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis数据类型List命令/" itemprop="url">
                  redis数据类型List命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T15:02:19+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis数据类型List命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis数据类型List命令/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-list介绍"><a href="#redis-list介绍" class="headerlink" title="redis list介绍"></a><strong>redis list介绍</strong></h1><pre><code>列表类型（list）可以存储一个有序的字符串列表，
常用的操作是向列表两端添加元素，或者获得列表的某一个片段。
列表类型内部是使用双向链表（double linked list）实现的，
所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。
这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。
</code></pre><h1 id="向列表两端增加元素"><a href="#向列表两端增加元素" class="headerlink" title="向列表两端增加元素"></a>向列表两端增加元素</h1><p>LPUSH key value [value …]  向列表左边增加元素 </p>
<pre><code>127.0.0.1:6379&gt; lpush list:1 1 2 3
(integer) 3
</code></pre><p>RPUSH key value [value …]  向列表右边增加元素 </p>
<pre><code>127.0.0.1:6379&gt; rpush list:1 4 5 6
(integer) 3
</code></pre><h1 id="查看列表"><a href="#查看列表" class="headerlink" title="查看列表"></a>查看列表</h1><pre><code>LRANGE命令是列表类型最常用的命令之一，
获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），
索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。
</code></pre><p>LRANGE key start stop </p>
<pre><code>127.0.0.1:6379&gt; lrange list:1 0 2
1) &quot;2&quot;
2) &quot;1&quot;
3) &quot;4&quot;
</code></pre><h1 id="从列表两端弹出元素"><a href="#从列表两端弹出元素" class="headerlink" title="从列表两端弹出元素"></a>从列表两端弹出元素</h1><pre><code>LPOP命令从列表左边弹出一个元素，会分两步完成：
第一步是将列表左边的元素从列表中移除
第二步是返回被移除的元素值。
</code></pre><p>LPOP key </p>
<p>RPOP key</p>
<pre><code>127.0.0.1:6379&gt; lpop list:1
&quot;3“
127.0.0.1:6379&gt; rpop list:1
&quot;6“
</code></pre><h1 id="获取列表中元素的个数"><a href="#获取列表中元素的个数" class="headerlink" title="获取列表中元素的个数"></a>获取列表中元素的个数</h1><pre><code>127.0.0.1:6379&gt; llen list:1
(integer) 2
</code></pre><h1 id="删除列表中指定的值"><a href="#删除列表中指定的值" class="headerlink" title="删除列表中指定的值"></a>删除列表中指定的值</h1><pre><code>LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同： 
当count&gt;0时， LREM会从列表左边开始删除。 
当count&lt;0时， LREM会从列表后边开始删除。 
当count=0时， LREM删除所有值为value的元素。 

语法：LREM key count value
</code></pre><h1 id="获得-设置指定索引的元素值"><a href="#获得-设置指定索引的元素值" class="headerlink" title="获得/设置指定索引的元素值"></a>获得/设置指定索引的元素值</h1><p>LINDEX key index     获得指定索引的元素值</p>
<pre><code>127.0.0.1:6379&gt; lindex l:list 2
&quot;1&quot;
</code></pre><p>LSET key index value      设置指定索引的元素值</p>
<pre><code>127.0.0.1:6379&gt; lset l:list 2 2
OK
127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;2&quot;
4) &quot;2&quot;
</code></pre><h1 id="只保留列表指定片段"><a href="#只保留列表指定片段" class="headerlink" title="只保留列表指定片段"></a>只保留列表指定片段</h1><p>LTRIM key start stop 指定范围和LRANGE一致 </p>
<pre><code>127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;0&quot;
4) &quot;2&quot;
127.0.0.1:6379&gt; ltrim l:list 0 2
OK
127.0.0.1:6379&gt; lrange l:list 0 -1
1) &quot;6&quot;
2) &quot;5&quot;
3) &quot;0&quot;
</code></pre><h1 id="向列表中插入元素"><a href="#向列表中插入元素" class="headerlink" title="向列表中插入元素"></a>向列表中插入元素</h1><pre><code>该命令首先会在列表中从左到右查找值为pivot的元素，
然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。
</code></pre><p>LINSERT key BEFORE|AFTER pivot value</p>
<pre><code>127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;2&quot;
3) &quot;1&quot;
127.0.0.1:6379&gt; linsert list after 3 4
(integer) 4
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;2&quot;
4) &quot;1&quot;
</code></pre><h1 id="将元素从一个列表转移到另一个列表中"><a href="#将元素从一个列表转移到另一个列表中" class="headerlink" title="将元素从一个列表转移到另一个列表中"></a>将元素从一个列表转移到另一个列表中</h1><p>RPOPLPUSH source destination</p>
<pre><code>127.0.0.1:6379&gt; rpoplpush list newlist 
&quot;1&quot;
127.0.0.1:6379&gt; lrange newlist 0 -1
1) &quot;1&quot;
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;2&quot;
</code></pre><h1 id="List应用"><a href="#List应用" class="headerlink" title="List应用"></a>List应用</h1><h2 id="商品评论列表"><a href="#商品评论列表" class="headerlink" title="商品评论列表"></a>商品评论列表</h2><pre><code>在Redis中创建商品评论列表
用户发布商品评论，将评论信息转成json存储到list中。
用户在页面查询评论列表，从redis中取出json数据展示到页面。
</code></pre><p>商品编号为1001的商品评论key【items: comment:1001】</p>
<pre><code>192.168.101.3:7001&gt; LPUSH items:comment:1001 &apos;{&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289}&apos;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis数据类型Hash命令/" itemprop="url">
                  redis数据类型Hash命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T14:36:40+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis数据类型Hash命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis数据类型Hash命令/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a><strong>Hash类型</strong></h1><p>hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下：<br><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/redis_hash.jpg" alt=""></p>
<h1 id="Hash命令"><a href="#Hash命令" class="headerlink" title="Hash命令"></a><strong>Hash命令</strong></h1><p>HSET key field value  赋值</p>
<pre><code>HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。

127.0.0.1:6379&gt; hset user username zhangsan 
(integer) 1
</code></pre><p>HMSET key field value [field value …]      一次可以设置多个字段值</p>
<pre><code>127.0.0.1:6379&gt; hmset user age 20 username lisi 
OK
</code></pre><p>HSETNX key field value  当字段不存在时赋值</p>
<pre><code>当字段不存在时赋值，类似HSET，区别在于如果字段存在，该命令不执行任何操作

127.0.0.1:6379&gt; hsetnx user age 30    
如果user中没有age字段则设置age值为30，否则不做任何操作
(integer) 0
</code></pre><p>HGET key field  一次只能获取一个字段值</p>
<pre><code>127.0.0.1:6379&gt; hget user username
&quot;zhangsan“
</code></pre><p>HMGET key field [field …]    一次可以获取多个字段值</p>
<pre><code>127.0.0.1:6379&gt; hmget user age username
1) &quot;20&quot;
2) &quot;lisi&quot;
</code></pre><p>HGETALL key     获取所有字段值</p>
<pre><code>127.0.0.1:6379&gt; hgetall user
1) &quot;age&quot;
2) &quot;20&quot;
3) &quot;username&quot;
4) &quot;lisi&quot;
</code></pre><p>HDEL key field [field …]  可以删除一个或多个字段，返回值是被删除的字段个数 </p>
<pre><code>127.0.0.1:6379&gt; hdel user age
(integer) 1
127.0.0.1:6379&gt; hdel user age name
(integer) 0
127.0.0.1:6379&gt; hdel user age username
(integer) 1 
</code></pre><p>HINCRBY key field increment     增加值</p>
<pre><code>127.0.0.1:6379&gt; hincrby user age 2    将用户的年龄加2
(integer) 22
127.0.0.1:6379&gt; hget user age        获取用户的年龄
&quot;22“
</code></pre><p>HEXISTS key field     判断字段是否存在</p>
<pre><code>127.0.0.1:6379&gt; hexists user age        查看user中是否有age字段
(integer) 1
127.0.0.1:6379&gt; hexists user name    查看user中是否有name字段
(integer) 0
</code></pre><p>HKEYS key      只获取字段名</p>
<p>HVALS key   只获取字段值</p>
<pre><code>127.0.0.1:6379&gt; hmset user age 20 name lisi 
OK
127.0.0.1:6379&gt; hkeys user
1) &quot;age&quot;
2) &quot;name&quot;
127.0.0.1:6379&gt; hvals user
1) &quot;20&quot;
2) &quot;lisi&quot;
</code></pre><p>HLEN key 获取字段长度</p>
<pre><code>127.0.0.1:6379&gt; hlen user    
(integer) 2
</code></pre><h1 id="Hash应用"><a href="#Hash应用" class="headerlink" title="Hash应用"></a><strong>Hash应用</strong></h1><h1 id="存储商品信息"><a href="#存储商品信息" class="headerlink" title="存储商品信息:"></a>存储商品信息:</h1><p>商品字段</p>
<pre><code>【商品id、商品名称、商品描述、商品库存、商品好评】
</code></pre><p>定义商品信息的key</p>
<pre><code>商品1001的信息在 Redis中的key为：[items:1001]
</code></pre><p>储商品信息</p>
<pre><code>192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9
OK
</code></pre><p>获取商品信息</p>
<pre><code>192.168.101.3:7003&gt; HGET items:1001 id
&quot;3&quot;
192.168.101.3:7003&gt; HGETALL items:1001
1) &quot;id&quot;
2) &quot;3&quot;
3) &quot;name&quot;
4) &quot;apple&quot;
5) &quot;price&quot;
6) &quot;999.9&quot;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/redis数据类型及string命令/" itemprop="url">
                  redis数据类型String命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T13:59:39+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/redis数据类型及string命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/redis数据类型及string命令/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><strong>String类型</strong></h1><p>SET key value 赋值</p>
<pre><code>127.0.0.1:6379&gt; set test 123
OK
</code></pre><p>GET key  取值</p>
<pre><code>127.0.0.1:6379&gt; get test
&quot;123“
</code></pre><p>GETSET key value  取值并赋值</p>
<pre><code>127.0.0.1:6379&gt; getset s2 222
&quot;111&quot;
127.0.0.1:6379&gt; get s2
&quot;222&quot;
</code></pre><p>DEL key 删除</p>
<pre><code>127.0.0.1:6379&gt; del test
(integer) 1
</code></pre><p>incr key 递增数字 </p>
<p>当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。</p>
<pre><code>127.0.0.1:6379&gt; incr num
(integer) 1
127.0.0.1:6379&gt; incr num
(integer) 2
127.0.0.1:6379&gt; incr num
(integer) 3
</code></pre><p>INCRBY key increment 增加指定的整数 </p>
<pre><code>127.0.0.1:6379&gt; incrby num 2
(integer) 5
127.0.0.1:6379&gt; incrby num 2
(integer) 7
127.0.0.1:6379&gt; incrby num 2
(integer) 9
</code></pre><p>DECR key  递减数值</p>
<pre><code>127.0.0.1:6379&gt; decr num
(integer) 9
127.0.0.1:6379&gt; decr num
(integer) 8
</code></pre><p>DECRBY key decrement      减少指定的整数 </p>
<pre><code>127.0.0.1:6379&gt; decr num
(integer) 6
127.0.0.1:6379&gt; decr num
(integer) 5
127.0.0.1:6379&gt; decrby num 3
(integer) 2
127.0.0.1:6379&gt; decrby num 3
(integer) -1
</code></pre><p>APPEND key value      向尾部追加值 </p>
<pre><code>127.0.0.1:6379&gt; set str hello
OK
127.0.0.1:6379&gt; append str &quot; world!&quot;
(integer) 12
127.0.0.1:6379&gt; get str 
&quot;hello world!&quot;
</code></pre><p>STRLEN key 获取字符串长度</p>
<pre><code>127.0.0.1:6379&gt; strlen str 
(integer) 0
127.0.0.1:6379&gt; set str hello
OK
127.0.0.1:6379&gt; strlen str 
(integer) 5
</code></pre><p>MSET key value [key value …] 同时设置多个值</p>
<pre><code>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3
OK
</code></pre><p>MGET key [key …] 同时取多个值</p>
<pre><code>127.0.0.1:6379&gt; get k1
&quot;v1&quot;
127.0.0.1:6379&gt; mget k1 k3
1) &quot;v1&quot;
2) &quot;v3&quot;
</code></pre><h1 id="String应用"><a href="#String应用" class="headerlink" title="String应用"></a><strong>String应用</strong></h1><p>自增主键:  商品编号、订单号采用string的递增数字特性生成。</p>
<pre><code>定义商品编号key：items:id
192.168.101.3:7003&gt; INCR items:id
(integer) 2
192.168.101.3:7003&gt; INCR items:id
(integer) 3
</code></pre><h1 id="String存在的问题"><a href="#String存在的问题" class="headerlink" title="String存在的问题"></a><strong>String存在的问题</strong></h1><pre><code>假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age、name等属性，存储的过程如下： 
保存、更新： 
User对象  -&gt;  json(string)  -&gt;  redis 
如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 
如果仍然采用上边的方法在传输、处理时会造成资源浪费，下边讲的hash可以很好的解决这个问题。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/服务器搭建-四-redis配置/" itemprop="url">
                  服务器搭建-四-redis配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T11:55:31+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/服务器搭建-四-redis配置/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/服务器搭建-四-redis配置/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是NoSql"><a href="#什么是NoSql" class="headerlink" title="什么是NoSql"></a><strong>什么是NoSql</strong></h1><pre><code>为了解决高并发、高可扩展、高可用、大数据存储问题而产生的数据库解决方案，就是NoSql数据库。
NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充。
</code></pre><h1 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a><strong>什么是Redis</strong></h1><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如<br>下：</p>
<pre><code>字符串类型 
散列类型 (Hash类型)
列表类型 (List)
集合类型 (Set)
有序集合类型 (SortedSet)

在redis中的命令语句中，命令是忽略大小写的，而key是不忽略大小写的。
</code></pre><h1 id="redis的应用场景"><a href="#redis的应用场景" class="headerlink" title="redis的应用场景"></a><strong>redis的应用场景</strong></h1><pre><code>缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）
分布式集群架构中的session分离。
聊天室的在线好友列表。
任务队列。（秒杀、抢购、12306等等）
应用排行榜。
网站访问统计。
数据过期处理（可以精确到毫秒）
</code></pre><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a><strong>Redis安装</strong></h1><p>第一步.在Linux下安装gcc环境</p>
<pre><code>yum install gcc-c++
</code></pre><p>第二步. 安装redis</p>
<pre><code>1.将下载的Redis源码包上传到Linux服务器中
2.解压缩Redis源码包到/usr/local tar -zxf redis-3.0.0.tar.gz -C /usr/local
3.进入/usr/local/redis-3.0.0目录 
  编译redis源码 make
  安装redis make install PREFIX=/usr/local/redis0707
</code></pre><p>第三步. 后端启动redis</p>
<pre><code>1.将redis源码包中的redis.conf配置文件复制到/usr/local/redis/bin/下
  cp redis.conf /usr/local/redis0707/bin/
2.修改redis.conf，将daemonize由no改为yes
  37行 daemonize yes
3.启动redis-server 
  ./redis-server redis.conf
4.关闭redis-server
  ./redis-cli shutdown
5.打开redis客户端 ./redis-cli -h 127.0.0.1 -p 6379
</code></pre><h1 id="修改访问端口"><a href="#修改访问端口" class="headerlink" title="修改访问端口"></a><strong>修改访问端口</strong></h1><pre><code>1.通过notepad++ 打开/etc/sysconfig/iptables
2.添加-A INPUT -m state --state NEW -m tcp -p tcp --dport 6379 -j ACCEPT
3.重启防火墙  service iptables restart
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/服务器搭建-三-fastDFS图片服务器/" itemprop="url">
                  服务器搭建(三) fastDFS图片服务器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T09:02:42+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/16/服务器搭建-三-fastDFS图片服务器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/16/服务器搭建-三-fastDFS图片服务器/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="fastDFS流程"><a href="#fastDFS流程" class="headerlink" title="fastDFS流程"></a>fastDFS流程</h2><p>可以使用一台虚拟机来模拟，只有一个Tracker、一个Storage服务。配置nginx访问图片。<br><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/fastDFS.jpg" alt=""></p>
<h1 id="fastDFS搭建"><a href="#fastDFS搭建" class="headerlink" title="fastDFS搭建"></a><strong>fastDFS搭建</strong></h1><p>第一步：把fastDFS都上传到linux系统。</p>
<p>第二步：安装FastDFS之前，先安装libevent工具包。</p>
<pre><code>yum -y install libevent
</code></pre><p>第三步：安装libfastcommonV1.0.7工具包。</p>
<pre><code>1、解压缩
2、./make.sh
3、./make.sh install
4、把/usr/lib64/libfastcommon.so文件向/usr/lib/下复制一份
</code></pre><p>第四步：安装Tracker服务。</p>
<pre><code>1、解压缩fastDFS,将文件移动到/usr/local下
2、./make.sh
3、./make.sh install
安装后在/usr/bin/目录下有以fdfs开头的文件都是编译出来的。
配置文件都放到/etc/fdfs文件夹
4、把/usr/local/FastDFS/conf目录下的所有的配置文件都复制到/etc/fdfs下。
   cp * /etc/fdfs/
5、配置tracker服务。修改/usr/local/FastDFS/conf/tracker.conf文件。
6、修改tracker.conf中22行,base_path=/home/fastdfs/tracker
7、启动tracker。/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf
重启使用命令：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart
</code></pre><p>第五步：安装storage服务。</p>
<p>1、如果是在不同的服务器安装，第四步的1~4需要重新执行。<br>2、配置storage服务。修改/usr/local/FastDFS/conf/storage.conf文件</p>
<pre><code>41行 base_path=/home/fastdfs/storage
109行 store_path0=/home/fastdfs/storage
118行 tracker_server=115.159.93.201:22122
</code></pre><p>3、启动storage服务。</p>
<pre><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart    
</code></pre><p>第六步：测试服务。</p>
<p>1、修改配置文件/etc/fdfs/client.conf</p>
<pre><code>10行 base_path=/home/fastdfs/client
14行 tracker_server=115.159.93.201:22122
</code></pre><p>2、测试 </p>
<pre><code>/usr/bin/fdfs_test /etc/fdfs/client.conf upload anti-steal.jpg (在/etc/fdfs目录下)

生成 http://115.159.93.201/group1/M00/00/00/CmkaiVfbXw-ABpAJAABdrZgsqUU916_big.jpg 为图片的地址
</code></pre><p>第七步：搭建nginx提供http服务。</p>
<p>可以使用官方提供的nginx插件。要使用nginx插件需要重新编译。<br>fastdfs-nginx-module_v1.16.tar.gz</p>
<pre><code>1、解压插件压缩包,并移动到/usr/local
2、修改/usr/local/fastdfs-nginx-module/src/config文件，把其中的local去掉。
</code></pre><p>3、对nginx重新config</p>
<pre><code>./configure \
--prefix=/usr/local/nginx \
--pid-path=/var/run/nginx/nginx.pid \
--lock-path=/var/lock/nginx.lock \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--with-http_gzip_static_module \
--http-client-body-temp-path=/var/temp/nginx/client \
--http-proxy-temp-path=/var/temp/nginx/proxy \
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
--http-scgi-temp-path=/var/temp/nginx/scgi \
--add-module=/usr/local/fastdfs-nginx-module/src
</code></pre><p>4、make<br>5、make install<br>6、把/root/fastdfs-nginx-module/src/mod_fastdfs.conf文件复制到/etc/fdfs目录下。编辑：</p>
<pre><code>40行 tracker_server=115.159.93.201:22122
53行 url_have_group_name = true
62行 store_path0=/home/fastdfs/storage
</code></pre><p>7、nginx的配置<br>        在nginx的配置文件中添加一个Server：<br>        server {<br>                listen       80;<br>                server_name  115.159.93.201;</p>
<pre><code>        location /group1/M00/{
                #root /home/FastDFS/fdfs_storage/data;
                ngx_fastdfs_module;
        }
}
</code></pre><p>8、将libfdfsclient.so拷贝至/usr/lib下<br>cp /usr/lib64/libfdfsclient.so /usr/lib/<br>9、启动nginx</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/15/服务器搭建-二-Nginx和fastDFS配置/" itemprop="url">
                  服务器搭建(二)Nginx和fastDFS配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-15T22:48:47+08:00" content="2016-09-15">
              2016-09-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/15/服务器搭建-二-Nginx和fastDFS配置/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/15/服务器搭建-二-Nginx和fastDFS配置/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a><strong>Nginx反向代理</strong></h1><p>Nginx的配置文件：</p>
<pre><code>upstream tomcats{
   server 192.168.25.148:8080;  //配置多个tomcat
   server 192.168.25.148:8081;
  }

  server {
       listen       80;
       server_name  tomcat.taotao.com;

       #charset koi8-r;

       #access_log  logs/host.access.log  main;

       location / {
           proxy_pass   http://tomcats;  //设置代理
           index  index.html index.htm;
       }
  }
</code></pre><h1 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a><strong>Nginx负载均衡</strong></h1><p>只需要在upstream的server后面添加一个weight即可代表权重。权重越高，分配请求的数量(概率)就越多。默认权重是1</p>
<pre><code>upstream tomcats{
        server 192.168.25.148:8080 weight=2;  //设置权重为2
        server 192.168.25.148:8081;
       }

       server {
            listen       80;
            server_name  tomcat.taotao.com;

            #charset koi8-r;

            #access_log  logs/host.access.log  main;

            location / {
                proxy_pass   http://tomcats;  //设置代理
                index  index.html index.htm;
            }
       }
</code></pre><h1 id="fastDFS"><a href="#fastDFS" class="headerlink" title="fastDFS"></a><strong>fastDFS</strong></h1><p>FastDFS是用c语言编写的一款开源的分布式文件系统。FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p>
<h2 id="fastDFS上传流程"><a href="#fastDFS上传流程" class="headerlink" title="fastDFS上传流程"></a>fastDFS上传流程</h2><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/upload.jpg" alt=""></p>
<h2 id="fastDFS下载流程"><a href="#fastDFS下载流程" class="headerlink" title="fastDFS下载流程"></a>fastDFS下载流程</h2><p><img src="https://raw.githubusercontent.com/minokoko/minokoko.github.io/master/images/download.jpg" alt=""></p>
<p>客户端上传文件后存储服务器将文件ID返回给客户端，此文件ID用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。</p>
<pre><code>http://192.168.233.128/group1/M00/00/00/wKjpgFfGRCqAHIo6AADW-NO57MA805.jpg

组名：文件上传后所在的storage组名称，在文件上传成功后有storage服务器返回，需要客户端自行保存。 
虚拟磁盘路径：storage配置的虚拟路径，与磁盘选项store_path*对应。如果配置了store_path0则是M00，如果配置了store_path1则是M01，以此类推。
数据两级目录：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。
文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jessyon" />
          <p class="site-author-name" itemprop="name">Jessyon</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">29</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jessyon</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jessyon"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
